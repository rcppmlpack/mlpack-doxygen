<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1range.html">range</a></li><li class="navelem"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1range_1_1RangeSearch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches.  
 <a href="classmlpack_1_1range_1_1RangeSearch.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a56d716801a4d3390ba218a5de5d0ac63"><td class="memItemLeft" align="right" valign="top">typedef TreeType&lt; MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a></td></tr>
<tr class="memdesc:a56d716801a4d3390ba218a5de5d0ac63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef.  <a href="#a56d716801a4d3390ba218a5de5d0ac63">More...</a><br /></td></tr>
<tr class="separator:a56d716801a4d3390ba218a5de5d0ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc0bf4d8af5a5a3fdfe65802c1a849b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adc0bf4d8af5a5a3fdfe65802c1a849b4">RangeSearch</a> (const MatType &amp;<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a11b020a4f8da4e67e9d7df9559253174">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adfde3efd24902d19cbd49a6897dac353">naive</a>=false, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ac656f90d07f39fc821d5f04aa1e10720">singleMode</a>=false, const MetricType <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a959ee6af1678c911f32b13471df05f85">metric</a>=MetricType())</td></tr>
<tr class="memdesc:adc0bf4d8af5a5a3fdfe65802c1a849b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched).  <a href="#adc0bf4d8af5a5a3fdfe65802c1a849b4">More...</a><br /></td></tr>
<tr class="separator:adc0bf4d8af5a5a3fdfe65802c1a849b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd1f0bdad229e5ae6e7f175a0f1db98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3fd1f0bdad229e5ae6e7f175a0f1db98">RangeSearch</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a11b020a4f8da4e67e9d7df9559253174">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adfde3efd24902d19cbd49a6897dac353">naive</a>=false, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ac656f90d07f39fc821d5f04aa1e10720">singleMode</a>=false, const MetricType <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a959ee6af1678c911f32b13471df05f85">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a3fd1f0bdad229e5ae6e7f175a0f1db98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix.  <a href="#a3fd1f0bdad229e5ae6e7f175a0f1db98">More...</a><br /></td></tr>
<tr class="separator:a3fd1f0bdad229e5ae6e7f175a0f1db98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94872994a73b26b49b8c1952556f4ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ae94872994a73b26b49b8c1952556f4ad">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af4dd319afec22cdc66434513bcd6c48e">referenceTree</a>, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ac656f90d07f39fc821d5f04aa1e10720">singleMode</a>=false, const MetricType <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a959ee6af1678c911f32b13471df05f85">metric</a>=MetricType())</td></tr>
<tr class="memdesc:ae94872994a73b26b49b8c1952556f4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched).  <a href="#ae94872994a73b26b49b8c1952556f4ad">More...</a><br /></td></tr>
<tr class="separator:ae94872994a73b26b49b8c1952556f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75340fc85bd5daa8a7dab95dffd259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0d75340fc85bd5daa8a7dab95dffd259">RangeSearch</a> (const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adfde3efd24902d19cbd49a6897dac353">naive</a>=false, const bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ac656f90d07f39fc821d5f04aa1e10720">singleMode</a>=false, const MetricType <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a959ee6af1678c911f32b13471df05f85">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a0d75340fc85bd5daa8a7dab95dffd259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data.  <a href="#a0d75340fc85bd5daa8a7dab95dffd259">More...</a><br /></td></tr>
<tr class="separator:a0d75340fc85bd5daa8a7dab95dffd259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cb1b2767d362bdd550acb83bdc2feb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ae2cb1b2767d362bdd550acb83bdc2feb">RangeSearch</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:ae2cb1b2767d362bdd550acb83bdc2feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model.  <a href="#ae2cb1b2767d362bdd550acb83bdc2feb">More...</a><br /></td></tr>
<tr class="separator:ae2cb1b2767d362bdd550acb83bdc2feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4651ea430824ec02acc7ba1810c91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ab1d4651ea430824ec02acc7ba1810c91">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab1d4651ea430824ec02acc7ba1810c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model.  <a href="#ab1d4651ea430824ec02acc7ba1810c91">More...</a><br /></td></tr>
<tr class="separator:ab1d4651ea430824ec02acc7ba1810c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3812a7d101ec8f651983e1cacb013881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3812a7d101ec8f651983e1cacb013881">~RangeSearch</a> ()</td></tr>
<tr class="memdesc:a3812a7d101ec8f651983e1cacb013881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object.  <a href="#a3812a7d101ec8f651983e1cacb013881">More...</a><br /></td></tr>
<tr class="separator:a3812a7d101ec8f651983e1cacb013881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3656047218f17eb201150fae88ee7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aef3656047218f17eb201150fae88ee7f">BaseCases</a> () const </td></tr>
<tr class="memdesc:aef3656047218f17eb201150fae88ee7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of base cases during the last search.  <a href="#aef3656047218f17eb201150fae88ee7f">More...</a><br /></td></tr>
<tr class="separator:aef3656047218f17eb201150fae88ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a147d17543d8f26fddd47344caa875"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a74a147d17543d8f26fddd47344caa875">Naive</a> () const </td></tr>
<tr class="memdesc:a74a147d17543d8f26fddd47344caa875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether naive search is being used.  <a href="#a74a147d17543d8f26fddd47344caa875">More...</a><br /></td></tr>
<tr class="separator:a74a147d17543d8f26fddd47344caa875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd75a74bee18c2d5332d19913791722"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#accd75a74bee18c2d5332d19913791722">Naive</a> ()</td></tr>
<tr class="memdesc:accd75a74bee18c2d5332d19913791722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether naive search is being used.  <a href="#accd75a74bee18c2d5332d19913791722">More...</a><br /></td></tr>
<tr class="separator:accd75a74bee18c2d5332d19913791722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7d8cd71ff677fff203da04efdbea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ab4e7d8cd71ff677fff203da04efdbea6">operator=</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:ab4e7d8cd71ff677fff203da04efdbea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#ab4e7d8cd71ff677fff203da04efdbea6">More...</a><br /></td></tr>
<tr class="separator:ab4e7d8cd71ff677fff203da04efdbea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a6fafd7944f1992ba74d6028ffe06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a48a6fafd7944f1992ba74d6028ffe06c">operator=</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a48a6fafd7944f1992ba74d6028ffe06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#a48a6fafd7944f1992ba74d6028ffe06c">More...</a><br /></td></tr>
<tr class="separator:a48a6fafd7944f1992ba74d6028ffe06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671ec5dda79c51dd85e939a6ac51c1de"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a671ec5dda79c51dd85e939a6ac51c1de">ReferenceSet</a> () const </td></tr>
<tr class="memdesc:a671ec5dda79c51dd85e939a6ac51c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference set.  <a href="#a671ec5dda79c51dd85e939a6ac51c1de">More...</a><br /></td></tr>
<tr class="separator:a671ec5dda79c51dd85e939a6ac51c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706464bac7cb1159558b67bfdfd9a43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a706464bac7cb1159558b67bfdfd9a43f">ReferenceTree</a> ()</td></tr>
<tr class="memdesc:a706464bac7cb1159558b67bfdfd9a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference tree (or NULL if in naive mode).  <a href="#a706464bac7cb1159558b67bfdfd9a43f">More...</a><br /></td></tr>
<tr class="separator:a706464bac7cb1159558b67bfdfd9a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac815b1c7a77544900d9c6d3eca494"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#acdac815b1c7a77544900d9c6d3eca494">Scores</a> () const </td></tr>
<tr class="memdesc:acdac815b1c7a77544900d9c6d3eca494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of scores during the last search.  <a href="#acdac815b1c7a77544900d9c6d3eca494">More...</a><br /></td></tr>
<tr class="separator:acdac815b1c7a77544900d9c6d3eca494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7760049877247f43e0e75c09fc723ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a7760049877247f43e0e75c09fc723ee3">Search</a> (const MatType &amp;querySet, const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a7760049877247f43e0e75c09fc723ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#a7760049877247f43e0e75c09fc723ee3">More...</a><br /></td></tr>
<tr class="separator:a7760049877247f43e0e75c09fc723ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4764c10aaea589cdd9c8e21d0de1ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ad4764c10aaea589cdd9c8e21d0de1ce8">Search</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *queryTree, const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:ad4764c10aaea589cdd9c8e21d0de1ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#ad4764c10aaea589cdd9c8e21d0de1ce8">More...</a><br /></td></tr>
<tr class="separator:ad4764c10aaea589cdd9c8e21d0de1ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd96f099fb75f20301ea96571b3352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a93fd96f099fb75f20301ea96571b3352">Search</a> (const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a93fd96f099fb75f20301ea96571b3352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects.  <a href="#a93fd96f099fb75f20301ea96571b3352">More...</a><br /></td></tr>
<tr class="separator:a93fd96f099fb75f20301ea96571b3352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef21346f949577dc5af79e26485e309"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a6ef21346f949577dc5af79e26485e309"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a6ef21346f949577dc5af79e26485e309">Serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="memdesc:a6ef21346f949577dc5af79e26485e309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the model.  <a href="#a6ef21346f949577dc5af79e26485e309">More...</a><br /></td></tr>
<tr class="separator:a6ef21346f949577dc5af79e26485e309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c12e63ad76cb13c2df11b8d3c697a82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5c12e63ad76cb13c2df11b8d3c697a82">SingleMode</a> () const </td></tr>
<tr class="memdesc:a5c12e63ad76cb13c2df11b8d3c697a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether single-tree search is being used.  <a href="#a5c12e63ad76cb13c2df11b8d3c697a82">More...</a><br /></td></tr>
<tr class="separator:a5c12e63ad76cb13c2df11b8d3c697a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38f824cd17757de6297a7bcb70969c1"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ae38f824cd17757de6297a7bcb70969c1">SingleMode</a> ()</td></tr>
<tr class="memdesc:ae38f824cd17757de6297a7bcb70969c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether single-tree search is being used.  <a href="#ae38f824cd17757de6297a7bcb70969c1">More...</a><br /></td></tr>
<tr class="separator:ae38f824cd17757de6297a7bcb70969c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003da7634609d1798c5dc7debd923088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a003da7634609d1798c5dc7debd923088">Train</a> (const MatType &amp;<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a11b020a4f8da4e67e9d7df9559253174">referenceSet</a>)</td></tr>
<tr class="memdesc:a003da7634609d1798c5dc7debd923088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, and build a tree if necessary.  <a href="#a003da7634609d1798c5dc7debd923088">More...</a><br /></td></tr>
<tr class="separator:a003da7634609d1798c5dc7debd923088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e23439bf899737980455689f22c081c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5e23439bf899737980455689f22c081c">Train</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a11b020a4f8da4e67e9d7df9559253174">referenceSet</a>)</td></tr>
<tr class="memdesc:a5e23439bf899737980455689f22c081c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, taking ownership of the set.  <a href="#a5e23439bf899737980455689f22c081c">More...</a><br /></td></tr>
<tr class="separator:a5e23439bf899737980455689f22c081c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88789e2b6107b4f37cd726017630e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aa88789e2b6107b4f37cd726017630e0c">Train</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af4dd319afec22cdc66434513bcd6c48e">referenceTree</a>)</td></tr>
<tr class="memdesc:aa88789e2b6107b4f37cd726017630e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree to a new reference tree.  <a href="#aa88789e2b6107b4f37cd726017630e0c">More...</a><br /></td></tr>
<tr class="separator:aa88789e2b6107b4f37cd726017630e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab50e960886d53242ac37aeacbc05d766"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ab50e960886d53242ac37aeacbc05d766">baseCases</a></td></tr>
<tr class="memdesc:ab50e960886d53242ac37aeacbc05d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of base cases during the last search.  <a href="#ab50e960886d53242ac37aeacbc05d766">More...</a><br /></td></tr>
<tr class="separator:ab50e960886d53242ac37aeacbc05d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ee6af1678c911f32b13471df05f85"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a959ee6af1678c911f32b13471df05f85">metric</a></td></tr>
<tr class="memdesc:a959ee6af1678c911f32b13471df05f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiated distance metric.  <a href="#a959ee6af1678c911f32b13471df05f85">More...</a><br /></td></tr>
<tr class="separator:a959ee6af1678c911f32b13471df05f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde3efd24902d19cbd49a6897dac353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adfde3efd24902d19cbd49a6897dac353">naive</a></td></tr>
<tr class="memdesc:adfde3efd24902d19cbd49a6897dac353"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, O(n^2) naive computation is used.  <a href="#adfde3efd24902d19cbd49a6897dac353">More...</a><br /></td></tr>
<tr class="separator:adfde3efd24902d19cbd49a6897dac353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975bc6fc9cf8f3b7c38d5e66989f119"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0975bc6fc9cf8f3b7c38d5e66989f119">oldFromNewReferences</a></td></tr>
<tr class="memdesc:a0975bc6fc9cf8f3b7c38d5e66989f119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mappings to old reference indices (used when this object builds trees).  <a href="#a0975bc6fc9cf8f3b7c38d5e66989f119">More...</a><br /></td></tr>
<tr class="separator:a0975bc6fc9cf8f3b7c38d5e66989f119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b020a4f8da4e67e9d7df9559253174"><td class="memItemLeft" align="right" valign="top">const MatType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a11b020a4f8da4e67e9d7df9559253174">referenceSet</a></td></tr>
<tr class="memdesc:a11b020a4f8da4e67e9d7df9559253174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference set (data should be accessed using this).  <a href="#a11b020a4f8da4e67e9d7df9559253174">More...</a><br /></td></tr>
<tr class="separator:a11b020a4f8da4e67e9d7df9559253174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dd319afec22cdc66434513bcd6c48e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af4dd319afec22cdc66434513bcd6c48e">referenceTree</a></td></tr>
<tr class="memdesc:af4dd319afec22cdc66434513bcd6c48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference tree.  <a href="#af4dd319afec22cdc66434513bcd6c48e">More...</a><br /></td></tr>
<tr class="separator:af4dd319afec22cdc66434513bcd6c48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9742c82dba7d424f495e88b0b5dff16"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af9742c82dba7d424f495e88b0b5dff16">scores</a></td></tr>
<tr class="memdesc:af9742c82dba7d424f495e88b0b5dff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of scores during the last search.  <a href="#af9742c82dba7d424f495e88b0b5dff16">More...</a><br /></td></tr>
<tr class="separator:af9742c82dba7d424f495e88b0b5dff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1da342a95d7065ecebbd3a499ec453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aee1da342a95d7065ecebbd3a499ec453">setOwner</a></td></tr>
<tr class="memdesc:aee1da342a95d7065ecebbd3a499ec453"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we own the reference set.  <a href="#aee1da342a95d7065ecebbd3a499ec453">More...</a><br /></td></tr>
<tr class="separator:aee1da342a95d7065ecebbd3a499ec453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac656f90d07f39fc821d5f04aa1e10720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ac656f90d07f39fc821d5f04aa1e10720">singleMode</a></td></tr>
<tr class="memdesc:ac656f90d07f39fc821d5f04aa1e10720"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, single-tree computation is used.  <a href="#ac656f90d07f39fc821d5f04aa1e10720">More...</a><br /></td></tr>
<tr class="separator:ac656f90d07f39fc821d5f04aa1e10720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fe43c24f611f06aab98e6bb683da61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#ab8fe43c24f611f06aab98e6bb683da61">treeOwner</a></td></tr>
<tr class="memdesc:ab8fe43c24f611f06aab98e6bb683da61"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this object is responsible for deleting the trees.  <a href="#ab8fe43c24f611f06aab98e6bb683da61">More...</a><br /></td></tr>
<tr class="separator:ab8fe43c24f611f06aab98e6bb683da61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt;<br />
class mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;</h3>

<p>The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches. </p>
<p>It is implemented in the style of a generalized tree-independent dual-tree algorithm; for more details on the actual algorithm, see the <a class="el" href="classmlpack_1_1range_1_1RangeSearchRules.html" title="The RangeSearchRules class is a template helper class used by RangeSearch class when performing range...">RangeSearchRules</a> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>Metric to use for range search calculations. </td></tr>
    <tr><td class="paramname">MatType</td><td>Type of data to use. </td></tr>
    <tr><td class="paramname">TreeType</td><td>Type of tree to use; must satisfy the TreeType policy API. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00042">42</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a56d716801a4d3390ba218a5de5d0ac63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TreeType&lt;MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType&gt; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00046">46</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adc0bf4d8af5a5a3fdfe65802c1a849b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.</p>
<p>This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and passing them using a different constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Reference dataset. </td></tr>
    <tr><td class="paramname">naive</td><td>Whether the computation should be done in O(n^2) naive mode. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fd1f0bdad229e5ae6e7f175a0f1db98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix. </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.</p>
<p>This method will not copy the data matrix, but will take ownership of it, and depending on the type of tree used, may rearrange the points. If you would rather a copy be made, consider using the constructor that takes a const reference to the data instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, brute force naive search will be used (as opposed to dual-tree search). This overrides singleMode (if it is set to true). </td></tr>
    <tr><td class="paramname">singleMode</td><td>If true, single-tree search will be used (as opposed to dual-tree search). </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae94872994a73b26b49b8c1952556f4ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched). </p>
<p>Optionally, choose to use single-tree mode, which will not build a tree on query points. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be aware that mapping of the points back to their original indices is not done when this constructor is used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">referenceSet</td><td>Set of reference points corresponding to referenceTree. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d75340fc85bd5daa8a7dab95dffd259"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data. </p>
<p>If the monochromatic <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a7760049877247f43e0e75c09fc723ee3" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a003da7634609d1798c5dc7debd923088" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>, no results will be returned (since the reference set is empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">naive</td><td>Whether to use naive search. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2cb1b2767d362bdd550acb83bdc2feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model. </p>
<p>Note that this may be computationally intensive!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1d4651ea430824ec02acc7ba1810c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3812a7d101ec8f651983e1cacb013881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::~<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object. </p>
<p>If trees were created, they will be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aef3656047218f17eb201150fae88ee7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::BaseCases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of base cases during the last search. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00313">313</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00350">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::baseCases</a>.</p>

</div>
</div>
<a class="anchor" id="a74a147d17543d8f26fddd47344caa875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether naive search is being used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00308">308</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00342">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::naive</a>.</p>

</div>
</div>
<a class="anchor" id="accd75a74bee18c2d5332d19913791722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether naive search is being used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00310">310</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00342">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::naive</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e7d8cd71ff677fff203da04efdbea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48a6fafd7944f1992ba74d6028ffe06c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a671ec5dda79c51dd85e939a6ac51c1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::ReferenceSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reference set. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00322">322</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00334">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::referenceSet</a>.</p>

</div>
</div>
<a class="anchor" id="a706464bac7cb1159558b67bfdfd9a43f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a>* <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::ReferenceTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reference tree (or NULL if in naive mode). </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00325">325</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00331">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::referenceTree</a>.</p>

</div>
</div>
<a class="anchor" id="acdac815b1c7a77544900d9c6d3eca494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Scores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of scores during the last search. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00315">315</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00352">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::scores</a>, and <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a6ef21346f949577dc5af79e26485e309">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::Serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a7760049877247f43e0e75c09fc723ee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">querySet</td><td>Set of query points to search with. </td></tr>
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4764c10aaea589cdd9c8e21d0de1ce8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *&#160;</td>
          <td class="paramname"><em>queryTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<p>If either naive or singleMode are set to true, this will throw an invalid_argument exception; passing in a query tree implies dual-tree search.</p>
<p>If you want to use the reference tree as the query tree, instead call the overload of <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a7760049877247f43e0e75c09fc723ee3" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> that does not take a query set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93fd96f099fb75f20301ea96571b3352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlpack_1_1math.html#a927179bb8d2d0fb6164df385ab51cbce">math::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects. </p>
<p>This means that the query set and the reference set are the same.</p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ef21346f949577dc5af79e26485e309"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the model. </p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00315">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::Scores()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c12e63ad76cb13c2df11b8d3c697a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether single-tree search is being used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00303">303</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00344">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::singleMode</a>.</p>

</div>
</div>
<a class="anchor" id="ae38f824cd17757de6297a7bcb70969c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether single-tree search is being used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00305">305</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>References <a class="el" href="range__search_8hpp_source.html#l00344">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::singleMode</a>.</p>

</div>
</div>
<a class="anchor" id="a003da7634609d1798c5dc7debd923088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference set to a new reference set, and build a tree if necessary. </p>
<p>This method is called '<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a003da7634609d1798c5dc7debd923088" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e23439bf899737980455689f22c081c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference set to a new reference set, taking ownership of the set. </p>
<p>A tree is built if necessary. This method is called '<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a003da7634609d1798c5dc7debd923088" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa88789e2b6107b4f37cd726017630e0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference tree to a new reference tree. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab50e960886d53242ac37aeacbc05d766"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::baseCases</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of base cases during the last search. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00350">350</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00313">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::BaseCases()</a>.</p>

</div>
</div>
<a class="anchor" id="a959ee6af1678c911f32b13471df05f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiated distance metric. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00347">347</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfde3efd24902d19cbd49a6897dac353"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::naive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, O(n^2) naive computation is used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00342">342</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00308">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::Naive()</a>.</p>

</div>
</div>
<a class="anchor" id="a0975bc6fc9cf8f3b7c38d5e66989f119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::oldFromNewReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mappings to old reference indices (used when this object builds trees). </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00329">329</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11b020a4f8da4e67e9d7df9559253174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType* <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::referenceSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference set (data should be accessed using this). </p>
<p>In some situations we may be the owner of this. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00334">334</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00322">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::ReferenceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="af4dd319afec22cdc66434513bcd6c48e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a56d716801a4d3390ba218a5de5d0ac63">Tree</a>* <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::referenceTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference tree. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00331">331</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00325">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::ReferenceTree()</a>.</p>

</div>
</div>
<a class="anchor" id="af9742c82dba7d424f495e88b0b5dff16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::scores</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of scores during the last search. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00352">352</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00315">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::Scores()</a>.</p>

</div>
</div>
<a class="anchor" id="aee1da342a95d7065ecebbd3a499ec453"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::setOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we own the reference set. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00339">339</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac656f90d07f39fc821d5f04aa1e10720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::singleMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, single-tree computation is used. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00344">344</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="range__search_8hpp_source.html#l00303">mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;::SingleMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8fe43c24f611f06aab98e6bb683da61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">mlpack::range::RangeSearch</a>&lt; MetricType, MatType, TreeType &gt;::treeOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, this object is responsible for deleting the trees. </p>

<p>Definition at line <a class="el" href="range__search_8hpp_source.html#l00337">337</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/methods/range_search/<a class="el" href="range__search_8hpp_source.html">range_search.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
<script type="text/javascript">
var x = document.getElementsByClassName("formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width /= 4;
}
</script>
</html>
