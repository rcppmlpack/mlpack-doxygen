<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::neighbor::RASearch&lt; SortPolicy, MetricType, MatType, TreeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1neighbor.html">neighbor</a></li><li class="navelem"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1neighbor_1_1RASearch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::neighbor::RASearch&lt; SortPolicy, MetricType, MatType, TreeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> class: This class provides a generic manner to perform rank-approximate search via random-sampling.  
 <a href="classmlpack_1_1neighbor_1_1RASearch.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for mlpack::neighbor::RASearch&lt; SortPolicy, MetricType, MatType, TreeType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmlpack_1_1neighbor_1_1RASearch__inherit__graph.png" border="0" usemap="#mlpack_1_1neighbor_1_1RASearch_3_01SortPolicy_00_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mlpack_1_1neighbor_1_1RASearch_3_01SortPolicy_00_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map" id="mlpack_1_1neighbor_1_1RASearch_3_01SortPolicy_00_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map">
<area shape="rect" id="node2" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::KDTree \&gt;" alt="" coords="415,5,604,47"/>
<area shape="rect" id="node3" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::RTree \&gt;" alt="" coords="415,71,604,112"/>
<area shape="rect" id="node4" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::UBTree \&gt;" alt="" coords="415,136,604,177"/>
<area shape="rect" id="node5" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::StandardCoverTree \&gt;" alt="" coords="415,201,604,243"/>
<area shape="rect" id="node6" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::RPlusPlusTree \&gt;" alt="" coords="415,267,604,308"/>
<area shape="rect" id="node7" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::HilbertRTree \&gt;" alt="" coords="415,332,604,373"/>
<area shape="rect" id="node8" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::Octree \&gt;" alt="" coords="415,397,604,439"/>
<area shape="rect" id="node9" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::XTree \&gt;" alt="" coords="415,463,604,504"/>
<area shape="rect" id="node10" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::RPlusTree \&gt;" alt="" coords="415,528,604,569"/>
<area shape="rect" id="node11" href="classmlpack_1_1neighbor_1_1RASearch.html" title="mlpack::neighbor::RASearch\l\&lt; tree::RStarTree \&gt;" alt="" coords="415,593,604,635"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3e13ae35dd37f14be6ca36b8a8e9f07f"><td class="memItemLeft" align="right" valign="top">typedef TreeType&lt; MetricType, <a class="el" href="classmlpack_1_1neighbor_1_1RAQueryStat.html">RAQueryStat</a>&lt; SortPolicy &gt;, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a></td></tr>
<tr class="memdesc:a3e13ae35dd37f14be6ca36b8a8e9f07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef.  <a href="#a3e13ae35dd37f14be6ca36b8a8e9f07f">More...</a><br /></td></tr>
<tr class="separator:a3e13ae35dd37f14be6ca36b8a8e9f07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af7f0d946743c6966010e21c90ea88086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#af7f0d946743c6966010e21c90ea88086">RASearch</a> (const MatType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a662a805197694ee1341c0ef7800e0ee1">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a18f2c93069e148e5e315b13aadb21ed6">naive</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a56ce3cfd7a0141299f6a3c66914b50f6">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ac1fb9c1b7537ae23c71fc134d3b9424b">tau</a>=5, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a93ec20d349723ac74c3f29540448609a">alpha</a>=0.95, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7fb6d89326e1a1505841d26aba22796a">sampleAtLeaves</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a35f9759c372e2b775b3fffb1e8134da2">firstLeafExact</a>=false, const size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a4d91160745e4683ff8f6361418c9b111">singleSampleLimit</a>=20, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1be053d8441397ed562c44abf676edf7">metric</a>=MetricType())</td></tr>
<tr class="memdesc:af7f0d946743c6966010e21c90ea88086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object, passing both a reference dataset (this is the dataset that will be searched).  <a href="#af7f0d946743c6966010e21c90ea88086">More...</a><br /></td></tr>
<tr class="separator:af7f0d946743c6966010e21c90ea88086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01baf882b92153be07e1faea4c123d1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a01baf882b92153be07e1faea4c123d1f">RASearch</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a662a805197694ee1341c0ef7800e0ee1">referenceSet</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a18f2c93069e148e5e315b13aadb21ed6">naive</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a56ce3cfd7a0141299f6a3c66914b50f6">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ac1fb9c1b7537ae23c71fc134d3b9424b">tau</a>=5, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a93ec20d349723ac74c3f29540448609a">alpha</a>=0.95, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7fb6d89326e1a1505841d26aba22796a">sampleAtLeaves</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a35f9759c372e2b775b3fffb1e8134da2">firstLeafExact</a>=false, const size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a4d91160745e4683ff8f6361418c9b111">singleSampleLimit</a>=20, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1be053d8441397ed562c44abf676edf7">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a01baf882b92153be07e1faea4c123d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object, passing both a reference dataset (this is the dataset that will be searched).  <a href="#a01baf882b92153be07e1faea4c123d1f">More...</a><br /></td></tr>
<tr class="separator:a01baf882b92153be07e1faea4c123d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b2be116e579b216db532e8b9d2945"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a9f4b2be116e579b216db532e8b9d2945">RASearch</a> (<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1849f51e5de3bc8e1c84c0ebadfa7f35">referenceTree</a>, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a56ce3cfd7a0141299f6a3c66914b50f6">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ac1fb9c1b7537ae23c71fc134d3b9424b">tau</a>=5, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a93ec20d349723ac74c3f29540448609a">alpha</a>=0.95, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7fb6d89326e1a1505841d26aba22796a">sampleAtLeaves</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a35f9759c372e2b775b3fffb1e8134da2">firstLeafExact</a>=false, const size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a4d91160745e4683ff8f6361418c9b111">singleSampleLimit</a>=20, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1be053d8441397ed562c44abf676edf7">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a9f4b2be116e579b216db532e8b9d2945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object with the given pre-constructed reference tree.  <a href="#a9f4b2be116e579b216db532e8b9d2945">More...</a><br /></td></tr>
<tr class="separator:a9f4b2be116e579b216db532e8b9d2945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738d3a4f1eb63be4888dcebbc2ba7888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a738d3a4f1eb63be4888dcebbc2ba7888">RASearch</a> (const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a18f2c93069e148e5e315b13aadb21ed6">naive</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a56ce3cfd7a0141299f6a3c66914b50f6">singleMode</a>=false, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ac1fb9c1b7537ae23c71fc134d3b9424b">tau</a>=5, const double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a93ec20d349723ac74c3f29540448609a">alpha</a>=0.95, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7fb6d89326e1a1505841d26aba22796a">sampleAtLeaves</a>=false, const bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a35f9759c372e2b775b3fffb1e8134da2">firstLeafExact</a>=false, const size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a4d91160745e4683ff8f6361418c9b111">singleSampleLimit</a>=20, const MetricType <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1be053d8441397ed562c44abf676edf7">metric</a>=MetricType())</td></tr>
<tr class="memdesc:a738d3a4f1eb63be4888dcebbc2ba7888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object with no reference data.  <a href="#a738d3a4f1eb63be4888dcebbc2ba7888">More...</a><br /></td></tr>
<tr class="separator:a738d3a4f1eb63be4888dcebbc2ba7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779381aa3d6e01f90b86b8227925c421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a779381aa3d6e01f90b86b8227925c421">~RASearch</a> ()</td></tr>
<tr class="memdesc:a779381aa3d6e01f90b86b8227925c421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object.  <a href="#a779381aa3d6e01f90b86b8227925c421">More...</a><br /></td></tr>
<tr class="separator:a779381aa3d6e01f90b86b8227925c421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925cb3cdbb9677cf658e07e3382ec1b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a925cb3cdbb9677cf658e07e3382ec1b5">Alpha</a> () const </td></tr>
<tr class="memdesc:a925cb3cdbb9677cf658e07e3382ec1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the desired success probability.  <a href="#a925cb3cdbb9677cf658e07e3382ec1b5">More...</a><br /></td></tr>
<tr class="separator:a925cb3cdbb9677cf658e07e3382ec1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfa93a9ff2cdc866309af708e423e9a"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a9cfa93a9ff2cdc866309af708e423e9a">Alpha</a> ()</td></tr>
<tr class="memdesc:a9cfa93a9ff2cdc866309af708e423e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the desired success probability.  <a href="#a9cfa93a9ff2cdc866309af708e423e9a">More...</a><br /></td></tr>
<tr class="separator:a9cfa93a9ff2cdc866309af708e423e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41645e5ea9490ea5f07a4f2fb1c702e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a41645e5ea9490ea5f07a4f2fb1c702e8">FirstLeafExact</a> () const </td></tr>
<tr class="memdesc:a41645e5ea9490ea5f07a4f2fb1c702e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not we traverse to the first leaf without approximation.  <a href="#a41645e5ea9490ea5f07a4f2fb1c702e8">More...</a><br /></td></tr>
<tr class="separator:a41645e5ea9490ea5f07a4f2fb1c702e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7224f28cae2c82aeaad61fa7fd53861"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ab7224f28cae2c82aeaad61fa7fd53861">FirstLeafExact</a> ()</td></tr>
<tr class="memdesc:ab7224f28cae2c82aeaad61fa7fd53861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not we traverse to the first leaf without approximation.  <a href="#ab7224f28cae2c82aeaad61fa7fd53861">More...</a><br /></td></tr>
<tr class="separator:ab7224f28cae2c82aeaad61fa7fd53861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02311b938eeb67b5088e11366b943e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ae02311b938eeb67b5088e11366b943e1">Naive</a> () const </td></tr>
<tr class="memdesc:ae02311b938eeb67b5088e11366b943e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not naive (brute-force) search is used.  <a href="#ae02311b938eeb67b5088e11366b943e1">More...</a><br /></td></tr>
<tr class="separator:ae02311b938eeb67b5088e11366b943e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc93f6a2cc809f9ae06a877baf3561b"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aadc93f6a2cc809f9ae06a877baf3561b">Naive</a> ()</td></tr>
<tr class="memdesc:aadc93f6a2cc809f9ae06a877baf3561b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not naive (brute-force) search is used.  <a href="#aadc93f6a2cc809f9ae06a877baf3561b">More...</a><br /></td></tr>
<tr class="separator:aadc93f6a2cc809f9ae06a877baf3561b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7ef452f19c9b7aae1f829605d893f7"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aee7ef452f19c9b7aae1f829605d893f7">ReferenceSet</a> () const </td></tr>
<tr class="memdesc:aee7ef452f19c9b7aae1f829605d893f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the reference set.  <a href="#aee7ef452f19c9b7aae1f829605d893f7">More...</a><br /></td></tr>
<tr class="separator:aee7ef452f19c9b7aae1f829605d893f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5063a3a67627e28220e3c6234b6643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aed5063a3a67627e28220e3c6234b6643">ResetQueryTree</a> (<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *queryTree) const </td></tr>
<tr class="memdesc:aed5063a3a67627e28220e3c6234b6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function recursively resets the <a class="el" href="classmlpack_1_1neighbor_1_1RAQueryStat.html" title="Extra data for each node in the tree. ">RAQueryStat</a> of the given query tree to set 'bound' to SortPolicy::WorstDistance and 'numSamplesMade' to 0.  <a href="#aed5063a3a67627e28220e3c6234b6643">More...</a><br /></td></tr>
<tr class="separator:aed5063a3a67627e28220e3c6234b6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b93f87c1c6050cee864eb2d292bef39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a6b93f87c1c6050cee864eb2d292bef39">SampleAtLeaves</a> () const </td></tr>
<tr class="memdesc:a6b93f87c1c6050cee864eb2d292bef39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not sampling is done at the leaves.  <a href="#a6b93f87c1c6050cee864eb2d292bef39">More...</a><br /></td></tr>
<tr class="separator:a6b93f87c1c6050cee864eb2d292bef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76669072a65439054d000c2f55db58cf"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a76669072a65439054d000c2f55db58cf">SampleAtLeaves</a> ()</td></tr>
<tr class="memdesc:a76669072a65439054d000c2f55db58cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not sampling is done at the leaves.  <a href="#a76669072a65439054d000c2f55db58cf">More...</a><br /></td></tr>
<tr class="separator:a76669072a65439054d000c2f55db58cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addedd4f8a4ac50ad6fe306b4b9fc25a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3">Search</a> (const MatType &amp;querySet, const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:addedd4f8a4ac50ad6fe306b4b9fc25a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank approximate nearest neighbors of each query point in the query set and store the output in the given matrices.  <a href="#addedd4f8a4ac50ad6fe306b4b9fc25a3">More...</a><br /></td></tr>
<tr class="separator:addedd4f8a4ac50ad6fe306b4b9fc25a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c7e537734e3c4204d115450ae586a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a10c7e537734e3c4204d115450ae586a1">Search</a> (<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *queryTree, const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:a10c7e537734e3c4204d115450ae586a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank approximate nearest neighbors of each point in the pre-built query tree and store the output in the given matrices.  <a href="#a10c7e537734e3c4204d115450ae586a1">More...</a><br /></td></tr>
<tr class="separator:a10c7e537734e3c4204d115450ae586a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4ae4eefa5e1e058a879a906f0d4794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1c4ae4eefa5e1e058a879a906f0d4794">Search</a> (const size_t k, arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:a1c4ae4eefa5e1e058a879a906f0d4794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank approximate nearest neighbors of each point in the reference set (that is, the query set is taken to be the reference set), and store the output in the given matrices.  <a href="#a1c4ae4eefa5e1e058a879a906f0d4794">More...</a><br /></td></tr>
<tr class="separator:a1c4ae4eefa5e1e058a879a906f0d4794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195b6eb6ce63de9f552f20afc5560ab"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:ad195b6eb6ce63de9f552f20afc5560ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ad195b6eb6ce63de9f552f20afc5560ab">Serialize</a> (Archive &amp;ar, const unsigned int)</td></tr>
<tr class="memdesc:ad195b6eb6ce63de9f552f20afc5560ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the object.  <a href="#ad195b6eb6ce63de9f552f20afc5560ab">More...</a><br /></td></tr>
<tr class="separator:ad195b6eb6ce63de9f552f20afc5560ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6e15542c59421db3211082f8d0b534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7a6e15542c59421db3211082f8d0b534">SingleMode</a> () const </td></tr>
<tr class="memdesc:a7a6e15542c59421db3211082f8d0b534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not single-tree search is used.  <a href="#a7a6e15542c59421db3211082f8d0b534">More...</a><br /></td></tr>
<tr class="separator:a7a6e15542c59421db3211082f8d0b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99af3e5d6684cb938d586bb145f9c5a2"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a99af3e5d6684cb938d586bb145f9c5a2">SingleMode</a> ()</td></tr>
<tr class="memdesc:a99af3e5d6684cb938d586bb145f9c5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether or not single-tree search is used.  <a href="#a99af3e5d6684cb938d586bb145f9c5a2">More...</a><br /></td></tr>
<tr class="separator:a99af3e5d6684cb938d586bb145f9c5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff287aa05faa9c7a7dabb4fc70dfe269"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aff287aa05faa9c7a7dabb4fc70dfe269">SingleSampleLimit</a> () const </td></tr>
<tr class="memdesc:aff287aa05faa9c7a7dabb4fc70dfe269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the limit on the size of a node that can be approximated.  <a href="#aff287aa05faa9c7a7dabb4fc70dfe269">More...</a><br /></td></tr>
<tr class="separator:aff287aa05faa9c7a7dabb4fc70dfe269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2c078bc40611c43db8e7e28af933c7"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7b2c078bc40611c43db8e7e28af933c7">SingleSampleLimit</a> ()</td></tr>
<tr class="memdesc:a7b2c078bc40611c43db8e7e28af933c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the limit on the size of a node that can be approximation.  <a href="#a7b2c078bc40611c43db8e7e28af933c7">More...</a><br /></td></tr>
<tr class="separator:a7b2c078bc40611c43db8e7e28af933c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89da1168110015b04b8c4a3806df6037"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a89da1168110015b04b8c4a3806df6037">Tau</a> () const </td></tr>
<tr class="memdesc:a89da1168110015b04b8c4a3806df6037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank-approximation in percentile of the data.  <a href="#a89da1168110015b04b8c4a3806df6037">More...</a><br /></td></tr>
<tr class="separator:a89da1168110015b04b8c4a3806df6037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713a46af14d5df94e2504704b9e88a19"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a713a46af14d5df94e2504704b9e88a19">Tau</a> ()</td></tr>
<tr class="memdesc:a713a46af14d5df94e2504704b9e88a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the rank-approximation in percentile of the data.  <a href="#a713a46af14d5df94e2504704b9e88a19">More...</a><br /></td></tr>
<tr class="separator:a713a46af14d5df94e2504704b9e88a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b583c83313263deb6e37053a933b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aa1b583c83313263deb6e37053a933b71">Train</a> (const MatType &amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a662a805197694ee1341c0ef7800e0ee1">referenceSet</a>)</td></tr>
<tr class="memdesc:aa1b583c83313263deb6e37053a933b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Train" the model on the given reference set.  <a href="#aa1b583c83313263deb6e37053a933b71">More...</a><br /></td></tr>
<tr class="separator:aa1b583c83313263deb6e37053a933b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a4ce71b49279f6177bc4c83e8f4742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a41a4ce71b49279f6177bc4c83e8f4742">Train</a> (MatType &amp;&amp;<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a662a805197694ee1341c0ef7800e0ee1">referenceSet</a>)</td></tr>
<tr class="memdesc:a41a4ce71b49279f6177bc4c83e8f4742"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Train" the model on the given reference set, taking ownership of the data matrix.  <a href="#a41a4ce71b49279f6177bc4c83e8f4742">More...</a><br /></td></tr>
<tr class="separator:a41a4ce71b49279f6177bc4c83e8f4742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a93ec20d349723ac74c3f29540448609a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a93ec20d349723ac74c3f29540448609a">alpha</a></td></tr>
<tr class="memdesc:a93ec20d349723ac74c3f29540448609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The desired success probability (between 0 and 1).  <a href="#a93ec20d349723ac74c3f29540448609a">More...</a><br /></td></tr>
<tr class="separator:a93ec20d349723ac74c3f29540448609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f9759c372e2b775b3fffb1e8134da2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a35f9759c372e2b775b3fffb1e8134da2">firstLeafExact</a></td></tr>
<tr class="memdesc:a35f9759c372e2b775b3fffb1e8134da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we will traverse to the first leaf without approximation.  <a href="#a35f9759c372e2b775b3fffb1e8134da2">More...</a><br /></td></tr>
<tr class="separator:a35f9759c372e2b775b3fffb1e8134da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be053d8441397ed562c44abf676edf7"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1be053d8441397ed562c44abf676edf7">metric</a></td></tr>
<tr class="memdesc:a1be053d8441397ed562c44abf676edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiation of kernel.  <a href="#a1be053d8441397ed562c44abf676edf7">More...</a><br /></td></tr>
<tr class="separator:a1be053d8441397ed562c44abf676edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2c93069e148e5e315b13aadb21ed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a18f2c93069e148e5e315b13aadb21ed6">naive</a></td></tr>
<tr class="memdesc:a18f2c93069e148e5e315b13aadb21ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if naive random sampling on the set is being used.  <a href="#a18f2c93069e148e5e315b13aadb21ed6">More...</a><br /></td></tr>
<tr class="separator:a18f2c93069e148e5e315b13aadb21ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dddad8b7aede5b9fc6fc8976abf6bcb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a0dddad8b7aede5b9fc6fc8976abf6bcb">oldFromNewReferences</a></td></tr>
<tr class="memdesc:a0dddad8b7aede5b9fc6fc8976abf6bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutations of reference points during tree building.  <a href="#a0dddad8b7aede5b9fc6fc8976abf6bcb">More...</a><br /></td></tr>
<tr class="separator:a0dddad8b7aede5b9fc6fc8976abf6bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662a805197694ee1341c0ef7800e0ee1"><td class="memItemLeft" align="right" valign="top">const MatType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a662a805197694ee1341c0ef7800e0ee1">referenceSet</a></td></tr>
<tr class="memdesc:a662a805197694ee1341c0ef7800e0ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference dataset. In some situations we may own this dataset.  <a href="#a662a805197694ee1341c0ef7800e0ee1">More...</a><br /></td></tr>
<tr class="separator:a662a805197694ee1341c0ef7800e0ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1849f51e5de3bc8e1c84c0ebadfa7f35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a1849f51e5de3bc8e1c84c0ebadfa7f35">referenceTree</a></td></tr>
<tr class="memdesc:a1849f51e5de3bc8e1c84c0ebadfa7f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root of the reference tree.  <a href="#a1849f51e5de3bc8e1c84c0ebadfa7f35">More...</a><br /></td></tr>
<tr class="separator:a1849f51e5de3bc8e1c84c0ebadfa7f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6d89326e1a1505841d26aba22796a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a7fb6d89326e1a1505841d26aba22796a">sampleAtLeaves</a></td></tr>
<tr class="memdesc:a7fb6d89326e1a1505841d26aba22796a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not sampling is done at the leaves. Faster, but less accurate.  <a href="#a7fb6d89326e1a1505841d26aba22796a">More...</a><br /></td></tr>
<tr class="separator:a7fb6d89326e1a1505841d26aba22796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6055d7ab252c0819d8fdf7580ef4cca9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a6055d7ab252c0819d8fdf7580ef4cca9">setOwner</a></td></tr>
<tr class="memdesc:a6055d7ab252c0819d8fdf7580ef4cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we are responsible for deleting the dataset.  <a href="#a6055d7ab252c0819d8fdf7580ef4cca9">More...</a><br /></td></tr>
<tr class="separator:a6055d7ab252c0819d8fdf7580ef4cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce3cfd7a0141299f6a3c66914b50f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a56ce3cfd7a0141299f6a3c66914b50f6">singleMode</a></td></tr>
<tr class="memdesc:a56ce3cfd7a0141299f6a3c66914b50f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if single-tree search is being used (opposed to dual-tree).  <a href="#a56ce3cfd7a0141299f6a3c66914b50f6">More...</a><br /></td></tr>
<tr class="separator:a56ce3cfd7a0141299f6a3c66914b50f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91160745e4683ff8f6361418c9b111"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a4d91160745e4683ff8f6361418c9b111">singleSampleLimit</a></td></tr>
<tr class="memdesc:a4d91160745e4683ff8f6361418c9b111"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit on the number of points in the largest node that can be approximated by sampling.  <a href="#a4d91160745e4683ff8f6361418c9b111">More...</a><br /></td></tr>
<tr class="separator:a4d91160745e4683ff8f6361418c9b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb9c1b7537ae23c71fc134d3b9424b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ac1fb9c1b7537ae23c71fc134d3b9424b">tau</a></td></tr>
<tr class="memdesc:ac1fb9c1b7537ae23c71fc134d3b9424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank-approximation in percentile of the data (between 0 and 100).  <a href="#ac1fb9c1b7537ae23c71fc134d3b9424b">More...</a><br /></td></tr>
<tr class="separator:ac1fb9c1b7537ae23c71fc134d3b9424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada78ea03de8ed12f078dd23727d231aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#ada78ea03de8ed12f078dd23727d231aa">treeOwner</a></td></tr>
<tr class="memdesc:ada78ea03de8ed12f078dd23727d231aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this object created the trees and is responsible for them.  <a href="#ada78ea03de8ed12f078dd23727d231aa">More...</a><br /></td></tr>
<tr class="separator:ada78ea03de8ed12f078dd23727d231aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt;<br />
class mlpack::neighbor::RASearch&lt; SortPolicy, MetricType, MatType, TreeType &gt;</h3>

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> class: This class provides a generic manner to perform rank-approximate search via random-sampling. </p>
<p>If the 'naive' option is chosen, this rank-approximate search will be done by randomly sampling from the whole set. If the 'naive' option is not chosen, the sampling is done in a stratified manner in the tree as mentioned in the algorithms in Figure 2 of the following paper:</p>
<p>{ram2009rank, title={{Rank-Approximate Nearest Neighbor Search: Retaining Meaning and Speed in High Dimensions}}, author={{Ram, P. and Lee, D. and Ouyang, H. and Gray, A. G.}}, booktitle={{Advances of Neural Information Processing Systems}}, year={2009} }</p>
<p><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> is currently known to not work with ball trees (#356).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SortPolicy</td><td>The sort policy for distances; see <a class="el" href="classmlpack_1_1neighbor_1_1NearestNeighborSort.html" title="This class implements the necessary methods for the SortPolicy template parameter of the NeighborSear...">NearestNeighborSort</a>. </td></tr>
    <tr><td class="paramname">MetricType</td><td>The metric to use for computation. </td></tr>
    <tr><td class="paramname">TreeType</td><td>The tree type to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00071">71</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3e13ae35dd37f14be6ca36b8a8e9f07f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TreeType&lt;MetricType, <a class="el" href="classmlpack_1_1neighbor_1_1RAQueryStat.html">RAQueryStat</a>&lt;SortPolicy&gt;, MatType&gt; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00075">75</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7f0d946743c6966010e21c90ea88086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>singleSampleLimit</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object, passing both a reference dataset (this is the dataset that will be searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and using the appropriate constructor, or by using the constructor that takes an rvalue reference to the data with std::move().</p>
<p>tau, the rank-approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95% probability of being in the top 5% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.95.</p>
<p>The method will fail (and throw a std::invalid_argument exception) if the value of tau is too low: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point &ndash; this is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. </td></tr>
    <tr><td class="paramname">singleMode</td><td>If true, single-tree search will be used (as opposed to dual-tree search). This is useful when <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3" title="Compute the rank approximate nearest neighbors of each query point in the query set and store the out...">Search()</a> will be called with few query points. </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
    <tr><td class="paramname">tau</td><td>The rank-approximation in percentile of the data. The default value is 5%. </td></tr>
    <tr><td class="paramname">alpha</td><td>The desired success probability. The default value is 0.95. </td></tr>
    <tr><td class="paramname">sampleAtLeaves</td><td>Sample at leaves for faster but less accurate computation. This defaults to 'false'. </td></tr>
    <tr><td class="paramname">firstLeafExact</td><td>Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to 'false' for now. </td></tr>
    <tr><td class="paramname">singleSampleLimit</td><td>The limit on the largest node that can be approximated by sampling. This defaults to 20. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01baf882b92153be07e1faea4c123d1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>singleSampleLimit</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object, passing both a reference dataset (this is the dataset that will be searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p>
<p>This method will take ownership of the given reference set, avoiding a copy. If you need to use the reference set for other purposes, too, consider using the constructor that takes a const reference.</p>
<p>tau, the rank-approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95% probability of being in the top 5% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.95.</p>
<p>The method will fail (and throw a std::invalid_argument exception) if the value of tau is too low: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point &ndash; this is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference points. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. </td></tr>
    <tr><td class="paramname">singleMode</td><td>If true, single-tree search will be used (as opposed to dual-tree search). This is useful when <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3" title="Compute the rank approximate nearest neighbors of each query point in the query set and store the out...">Search()</a> will be called with few query points. </td></tr>
    <tr><td class="paramname">metric</td><td>An optional instance of the MetricType class. </td></tr>
    <tr><td class="paramname">tau</td><td>The rank-approximation in percentile of the data. The default value is 5%. </td></tr>
    <tr><td class="paramname">alpha</td><td>The desired success probability. The default value is 0.95. </td></tr>
    <tr><td class="paramname">sampleAtLeaves</td><td>Sample at leaves for faster but less accurate computation. This defaults to 'false'. </td></tr>
    <tr><td class="paramname">firstLeafExact</td><td>Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to 'false' for now. </td></tr>
    <tr><td class="paramname">singleSampleLimit</td><td>The limit on the largest node that can be approximated by sampling. This defaults to 20. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f4b2be116e579b216db532e8b9d2945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>singleSampleLimit</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object with the given pre-constructed reference tree. </p>
<p>It is assumed that the points in the tree's dataset correspond to the reference set. Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, use a different constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<p>tau, the rank-approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95% probability of being in the top 5% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.95.</p>
<p>The method will fail (and throw a std::invalid_argument exception) if the value of tau is too low: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point &ndash; this is invalid.</p>
<dl class="section note"><dt>Note</dt><dd>Tree-building may (at least with BinarySpaceTree) modify the ordering of a matrix, so be aware that the results you get from <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3" title="Compute the rank approximate nearest neighbors of each query point in the query set and store the out...">Search()</a> will correspond to the modified matrix. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">tau</td><td>The rank-approximation in percentile of the data. The default value is 5%. </td></tr>
    <tr><td class="paramname">alpha</td><td>The desired success probability. The default value is 0.95. </td></tr>
    <tr><td class="paramname">sampleAtLeaves</td><td>Sample at leaves for faster but less accurate computation. This defaults to 'false'. </td></tr>
    <tr><td class="paramname">firstLeafExact</td><td>Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to 'false' for now. </td></tr>
    <tr><td class="paramname">singleSampleLimit</td><td>The limit on the largest node that can be approximated by sampling. This defaults to 20. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a738d3a4f1eb63be4888dcebbc2ba7888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>singleSampleLimit</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object with no reference data. </p>
<p>If <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3" title="Compute the rank approximate nearest neighbors of each query point in the query set and store the out...">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aa1b583c83313263deb6e37053a933b71" title="&quot;Train&quot; the model on the given reference set. ">Train()</a>, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">naive</td><td>Whether naive (brute-force) search should be used. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">tau</td><td>The rank-approximation in percentile of the data. The default value is 5%. </td></tr>
    <tr><td class="paramname">alpha</td><td>The desired success probability. The default value is 0.95. </td></tr>
    <tr><td class="paramname">sampleAtLeaves</td><td>Sample at leaves for faster but less accurate computation. This defaults to 'false'. </td></tr>
    <tr><td class="paramname">firstLeafExact</td><td>Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to 'false' for now. </td></tr>
    <tr><td class="paramname">singleSampleLimit</td><td>The limit on the largest node that can be approximated by sampling. This defaults to 20. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a779381aa3d6e01f90b86b8227925c421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::~<a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">RASearch</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> object. </p>
<p>The tree is the only member we are responsible for deleting. The others will take care of themselves. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a925cb3cdbb9677cf658e07e3382ec1b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the desired success probability. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00398">398</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cfa93a9ff2cdc866309af708e423e9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Alpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the desired success probability. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00400">400</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41645e5ea9490ea5f07a4f2fb1c702e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::FirstLeafExact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether or not we traverse to the first leaf without approximation. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00408">408</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7224f28cae2c82aeaad61fa7fd53861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::FirstLeafExact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not we traverse to the first leaf without approximation. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00410">410</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae02311b938eeb67b5088e11366b943e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether or not naive (brute-force) search is used. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00383">383</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aadc93f6a2cc809f9ae06a877baf3561b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not naive (brute-force) search is used. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00385">385</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee7ef452f19c9b7aae1f829605d893f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::ReferenceSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the reference set. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00380">380</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed5063a3a67627e28220e3c6234b6643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::ResetQueryTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *&#160;</td>
          <td class="paramname"><em>queryTree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function recursively resets the <a class="el" href="classmlpack_1_1neighbor_1_1RAQueryStat.html" title="Extra data for each node in the tree. ">RAQueryStat</a> of the given query tree to set 'bound' to SortPolicy::WorstDistance and 'numSamplesMade' to 0. </p>
<p>This allows a user to perform multiple searches with the same query tree, possibly with different levels of approximation without requiring to build a new pair of trees for every new (approximate) search.</p>
<p>If <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#addedd4f8a4ac50ad6fe306b4b9fc25a3" title="Compute the rank approximate nearest neighbors of each query point in the query set and store the out...">Search()</a> is called multiple times with the same query tree without calling <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aed5063a3a67627e28220e3c6234b6643" title="This function recursively resets the RAQueryStat of the given query tree to set &#39;bound&#39; to SortPolicy...">ResetQueryTree()</a>, the results may not satisfy the theoretical guarantees provided by the rank-approximate neighbor search algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree whose statistics should be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b93f87c1c6050cee864eb2d292bef39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SampleAtLeaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether or not sampling is done at the leaves. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00403">403</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76669072a65439054d000c2f55db58cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SampleAtLeaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not sampling is done at the leaves. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00405">405</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addedd4f8a4ac50ad6fe306b4b9fc25a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rank approximate nearest neighbors of each query point in the query set and store the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<p>If querySet is small or only contains one point, it can be faster to do single-tree search; single-tree search can be set with the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a99af3e5d6684cb938d586bb145f9c5a2" title="Modify whether or not single-tree search is used. ">SingleMode()</a> function or in the constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">querySet</td><td>Set of query points (can be a single point). </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10c7e537734e3c4204d115450ae586a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a> *&#160;</td>
          <td class="paramname"><em>queryTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rank approximate nearest neighbors of each point in the pre-built query tree and store the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<p>If singleMode or naive is enabled, then this method will throw a std::invalid_argument exception; calling this function implies a dual-tree algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>If the tree type you are using modifies the data matrix, be aware that the results returned from this function will be with respect to the modified data matrix. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c4ae4eefa5e1e058a879a906f0d4794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rank approximate nearest neighbors of each point in the reference set (that is, the query set is taken to be the reference set), and store the output in the given matrices. </p>
<p>The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad195b6eb6ce63de9f552f20afc5560ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the object. </p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00415">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::SingleSampleLimit()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6e15542c59421db3211082f8d0b534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether or not single-tree search is used. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00388">388</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99af3e5d6684cb938d586bb145f9c5a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether or not single-tree search is used. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00390">390</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff287aa05faa9c7a7dabb4fc70dfe269"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SingleSampleLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the limit on the size of a node that can be approximated. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00413">413</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b2c078bc40611c43db8e7e28af933c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::SingleSampleLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the limit on the size of a node that can be approximation. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00415">415</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89da1168110015b04b8c4a3806df6037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Tau </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank-approximation in percentile of the data. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00393">393</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a713a46af14d5df94e2504704b9e88a19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Tau </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the rank-approximation in percentile of the data. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00395">395</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1b583c83313263deb6e37053a933b71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Train" the model on the given reference set. </p>
<p>If tree-based search is being used (if <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aadc93f6a2cc809f9ae06a877baf3561b" title="Modify whether or not naive (brute-force) search is used. ">Naive()</a> is false), this means rebuilding the reference tree. This particular method will make a copy of the given reference data. To avoid that copy, use the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aa1b583c83313263deb6e37053a933b71" title="&quot;Train&quot; the model on the given reference set. ">Train()</a> method that takes an rvalue reference with std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New reference set to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41a4ce71b49279f6177bc4c83e8f4742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::Train </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Train" the model on the given reference set, taking ownership of the data matrix. </p>
<p>If tree-based search is being used (if <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aadc93f6a2cc809f9ae06a877baf3561b" title="Modify whether or not naive (brute-force) search is used. ">Naive()</a> is false), this also means rebuilding the reference tree. If you need to keep a copy of the reference data, use the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#aa1b583c83313263deb6e37053a933b71" title="&quot;Train&quot; the model on the given reference set. ">Train()</a> method that takes a const reference to the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New reference set to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a93ec20d349723ac74c3f29540448609a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::alpha</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The desired success probability (between 0 and 1). </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00442">442</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00398">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::Alpha()</a>.</p>

</div>
</div>
<a class="anchor" id="a35f9759c372e2b775b3fffb1e8134da2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::firstLeafExact</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we will traverse to the first leaf without approximation. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00446">446</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00408">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::FirstLeafExact()</a>.</p>

</div>
</div>
<a class="anchor" id="a1be053d8441397ed562c44abf676edf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiation of kernel. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00452">452</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18f2c93069e148e5e315b13aadb21ed6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::naive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if naive random sampling on the set is being used. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00435">435</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00383">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::Naive()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dddad8b7aede5b9fc6fc8976abf6bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::oldFromNewReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutations of reference points during tree building. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00423">423</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a662a805197694ee1341c0ef7800e0ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType* <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::referenceSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference dataset. In some situations we may own this dataset. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00427">427</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00380">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::ReferenceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a1849f51e5de3bc8e1c84c0ebadfa7f35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html#a3e13ae35dd37f14be6ca36b8a8e9f07f">Tree</a>* <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::referenceTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the root of the reference tree. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00425">425</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7fb6d89326e1a1505841d26aba22796a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::sampleAtLeaves</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not sampling is done at the leaves. Faster, but less accurate. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00444">444</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00403">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::SampleAtLeaves()</a>.</p>

</div>
</div>
<a class="anchor" id="a6055d7ab252c0819d8fdf7580ef4cca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::setOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we are responsible for deleting the dataset. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00432">432</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56ce3cfd7a0141299f6a3c66914b50f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::singleMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if single-tree search is being used (opposed to dual-tree). </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00437">437</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00388">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::SingleMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d91160745e4683ff8f6361418c9b111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::singleSampleLimit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The limit on the number of points in the largest node that can be approximated by sampling. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00449">449</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00413">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::SingleSampleLimit()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1fb9c1b7537ae23c71fc134d3b9424b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::tau</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank-approximation in percentile of the data (between 0 and 100). </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00440">440</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

<p>Referenced by <a class="el" href="ra__search_8hpp_source.html#l00393">mlpack::neighbor::RASearch&lt; tree::RStarTree &gt;::Tau()</a>.</p>

</div>
</div>
<a class="anchor" id="ada78ea03de8ed12f078dd23727d231aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html">mlpack::neighbor::RASearch</a>&lt; SortPolicy, MetricType, MatType, TreeType &gt;::treeOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, this object created the trees and is responsible for them. </p>

<p>Definition at line <a class="el" href="ra__search_8hpp_source.html#l00430">430</a> of file <a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/methods/rann/<a class="el" href="ra__search_8hpp_source.html">ra_search.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
<script type="text/javascript">
var x = document.getElementsByClassName("formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width /= 4;
}
</script>
</html>
