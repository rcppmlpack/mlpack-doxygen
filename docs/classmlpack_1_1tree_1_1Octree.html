<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1tree_1_1Octree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree_1_1DualTreeTraverser.html">DualTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual-tree traverser; see dual_tree_traverser.hpp.  <a href="classmlpack_1_1tree_1_1Octree_1_1DualTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree_1_1SingleTreeTraverser.html">SingleTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-tree traverser; see single_tree_traverser.hpp.  <a href="classmlpack_1_1tree_1_1Octree_1_1SingleTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlpack_1_1tree_1_1Octree_1_1SplitInfo.html">SplitInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used for sorting points while splitting.  <a href="structmlpack_1_1tree_1_1Octree_1_1SplitInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa20764e2edc49b577fa7f243ce126b0b"><td class="memItemLeft" align="right" valign="top">typedef MatType::elem_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a></td></tr>
<tr class="memdesc:aa20764e2edc49b577fa7f243ce126b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of element held in MatType.  <a href="#aa20764e2edc49b577fa7f243ce126b0b">More...</a><br /></td></tr>
<tr class="separator:aa20764e2edc49b577fa7f243ce126b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9a63472f0361d4e94500a55ed721ec"><td class="memItemLeft" align="right" valign="top">typedef MatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a4b9a63472f0361d4e94500a55ed721ec">Mat</a></td></tr>
<tr class="memdesc:a4b9a63472f0361d4e94500a55ed721ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">So other classes can use TreeType::Mat.  <a href="#a4b9a63472f0361d4e94500a55ed721ec">More...</a><br /></td></tr>
<tr class="separator:a4b9a63472f0361d4e94500a55ed721ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3feaf4d7a53d971d351e1e5205decce9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a3feaf4d7a53d971d351e1e5205decce9">Octree</a> (const MatType &amp;data, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a3feaf4d7a53d971d351e1e5205decce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#a3feaf4d7a53d971d351e1e5205decce9">More...</a><br /></td></tr>
<tr class="separator:a3feaf4d7a53d971d351e1e5205decce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e59c56541ff7e11befdf1e731cf61e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ae8e59c56541ff7e11befdf1e731cf61e">Octree</a> (const MatType &amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:ae8e59c56541ff7e11befdf1e731cf61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#ae8e59c56541ff7e11befdf1e731cf61e">More...</a><br /></td></tr>
<tr class="separator:ae8e59c56541ff7e11befdf1e731cf61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefcee9fb1e53e00d1c265834103fd9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#adefcee9fb1e53e00d1c265834103fd9d">Octree</a> (const MatType &amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, std::vector&lt; size_t &gt; &amp;newFromOld, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:adefcee9fb1e53e00d1c265834103fd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#adefcee9fb1e53e00d1c265834103fd9d">More...</a><br /></td></tr>
<tr class="separator:adefcee9fb1e53e00d1c265834103fd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a7221d80a2400885d2c4199c443289"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a84a7221d80a2400885d2c4199c443289">Octree</a> (MatType &amp;&amp;data, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a84a7221d80a2400885d2c4199c443289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#a84a7221d80a2400885d2c4199c443289">More...</a><br /></td></tr>
<tr class="separator:a84a7221d80a2400885d2c4199c443289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43fa19d1093a9715f26fb286e4f5cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ac43fa19d1093a9715f26fb286e4f5cea">Octree</a> (MatType &amp;&amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:ac43fa19d1093a9715f26fb286e4f5cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#ac43fa19d1093a9715f26fb286e4f5cea">More...</a><br /></td></tr>
<tr class="separator:ac43fa19d1093a9715f26fb286e4f5cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb535d33b6fc080d1cf9674486fbc9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#abbb535d33b6fc080d1cf9674486fbc9f">Octree</a> (MatType &amp;&amp;data, std::vector&lt; size_t &gt; &amp;oldFromNew, std::vector&lt; size_t &gt; &amp;newFromOld, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:abbb535d33b6fc080d1cf9674486fbc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of an octree on the given dataset.  <a href="#abbb535d33b6fc080d1cf9674486fbc9f">More...</a><br /></td></tr>
<tr class="separator:abbb535d33b6fc080d1cf9674486fbc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcb94baee247f81f7f521ae7463fdf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a0fcb94baee247f81f7f521ae7463fdf5">Octree</a> (<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *<a class="el" href="classmlpack_1_1tree_1_1Octree.html#a913f670e041d1fa24fb4a5955e315e73">parent</a>, const size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5f314dacb1bbb1ff4f74cb9d24b63617">begin</a>, const size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa5815470a4f5298b047345dbb8bd711b">count</a>, const arma::vec &amp;center, const double width, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a0fcb94baee247f81f7f521ae7463fdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, starting at column begin and using count points.  <a href="#a0fcb94baee247f81f7f521ae7463fdf5">More...</a><br /></td></tr>
<tr class="separator:a0fcb94baee247f81f7f521ae7463fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241177e4530ce48059c397bfb49dafbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a241177e4530ce48059c397bfb49dafbc">Octree</a> (<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *<a class="el" href="classmlpack_1_1tree_1_1Octree.html#a913f670e041d1fa24fb4a5955e315e73">parent</a>, const size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5f314dacb1bbb1ff4f74cb9d24b63617">begin</a>, const size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa5815470a4f5298b047345dbb8bd711b">count</a>, std::vector&lt; size_t &gt; &amp;oldFromNew, const arma::vec &amp;center, const double width, const size_t maxLeafSize=20)</td></tr>
<tr class="memdesc:a241177e4530ce48059c397bfb49dafbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, starting at column begin and using count points.  <a href="#a241177e4530ce48059c397bfb49dafbc">More...</a><br /></td></tr>
<tr class="separator:a241177e4530ce48059c397bfb49dafbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4833f2f942eeb03746903b6735b29f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a0b4833f2f942eeb03746903b6735b29f">Octree</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;other)</td></tr>
<tr class="memdesc:a0b4833f2f942eeb03746903b6735b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given tree.  <a href="#a0b4833f2f942eeb03746903b6735b29f">More...</a><br /></td></tr>
<tr class="separator:a0b4833f2f942eeb03746903b6735b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e67aa2ce3e3a83f035227be6229b4db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a0e67aa2ce3e3a83f035227be6229b4db">Octree</a> (<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a0e67aa2ce3e3a83f035227be6229b4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the given tree.  <a href="#a0e67aa2ce3e3a83f035227be6229b4db">More...</a><br /></td></tr>
<tr class="separator:a0e67aa2ce3e3a83f035227be6229b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0258ddedb29bff08e2bf4a715fe5f6"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a8a0258ddedb29bff08e2bf4a715fe5f6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a8a0258ddedb29bff08e2bf4a715fe5f6">Octree</a> (Archive &amp;ar, const typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; Archive::is_loading::value &gt; *=0)</td></tr>
<tr class="memdesc:a8a0258ddedb29bff08e2bf4a715fe5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the tree from a <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> archive.  <a href="#a8a0258ddedb29bff08e2bf4a715fe5f6">More...</a><br /></td></tr>
<tr class="separator:a8a0258ddedb29bff08e2bf4a715fe5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da105a7834635cc14ee186325beb0f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a8da105a7834635cc14ee186325beb0f6">~Octree</a> ()</td></tr>
<tr class="memdesc:a8da105a7834635cc14ee186325beb0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the tree.  <a href="#a8da105a7834635cc14ee186325beb0f6">More...</a><br /></td></tr>
<tr class="separator:a8da105a7834635cc14ee186325beb0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452cb2f0b6c58bb2436a01ac7927e327"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt; MetricType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a452cb2f0b6c58bb2436a01ac7927e327">Bound</a> () const </td></tr>
<tr class="memdesc:a452cb2f0b6c58bb2436a01ac7927e327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bound object for this node.  <a href="#a452cb2f0b6c58bb2436a01ac7927e327">More...</a><br /></td></tr>
<tr class="separator:a452cb2f0b6c58bb2436a01ac7927e327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7da5f4423534574566ce01bc3c3f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt; MetricType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aae7da5f4423534574566ce01bc3c3f32">Bound</a> ()</td></tr>
<tr class="memdesc:aae7da5f4423534574566ce01bc3c3f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the bound object for this node.  <a href="#aae7da5f4423534574566ce01bc3c3f32">More...</a><br /></td></tr>
<tr class="separator:aae7da5f4423534574566ce01bc3c3f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af210624bc714be08f915cda078aec311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#af210624bc714be08f915cda078aec311">Center</a> (arma::vec &amp;center) const </td></tr>
<tr class="memdesc:af210624bc714be08f915cda078aec311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the center of the bounding region in the given vector.  <a href="#af210624bc714be08f915cda078aec311">More...</a><br /></td></tr>
<tr class="separator:af210624bc714be08f915cda078aec311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695fa4f5c07257043836b2c314caca1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ad695fa4f5c07257043836b2c314caca1">Child</a> (const size_t child) const </td></tr>
<tr class="memdesc:ad695fa4f5c07257043836b2c314caca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified child.  <a href="#ad695fa4f5c07257043836b2c314caca1">More...</a><br /></td></tr>
<tr class="separator:ad695fa4f5c07257043836b2c314caca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ba544daa39ca1308d5a40fe63214f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a19ba544daa39ca1308d5a40fe63214f3">Child</a> (const size_t child)</td></tr>
<tr class="memdesc:a19ba544daa39ca1308d5a40fe63214f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified child.  <a href="#a19ba544daa39ca1308d5a40fe63214f3">More...</a><br /></td></tr>
<tr class="separator:a19ba544daa39ca1308d5a40fe63214f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822be90e25c3a9ffdc2b25aa3c96b8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a822be90e25c3a9ffdc2b25aa3c96b8bd">ChildPtr</a> (const size_t child)</td></tr>
<tr class="memdesc:a822be90e25c3a9ffdc2b25aa3c96b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the given child.  <a href="#a822be90e25c3a9ffdc2b25aa3c96b8bd">More...</a><br /></td></tr>
<tr class="separator:a822be90e25c3a9ffdc2b25aa3c96b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57220daa8b49ffd341441976fe6a3942"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a57220daa8b49ffd341441976fe6a3942">Dataset</a> () const </td></tr>
<tr class="memdesc:a57220daa8b49ffd341441976fe6a3942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dataset used by this node.  <a href="#a57220daa8b49ffd341441976fe6a3942">More...</a><br /></td></tr>
<tr class="separator:a57220daa8b49ffd341441976fe6a3942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5297ae382946af49d5dea20d13ea6da2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5297ae382946af49d5dea20d13ea6da2">Descendant</a> (const size_t index) const </td></tr>
<tr class="memdesc:a5297ae382946af49d5dea20d13ea6da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular descendant.  <a href="#a5297ae382946af49d5dea20d13ea6da2">More...</a><br /></td></tr>
<tr class="separator:a5297ae382946af49d5dea20d13ea6da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772c46a747904c85ca2b0633ccc77a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a772c46a747904c85ca2b0633ccc77a80">FurthestDescendantDistance</a> () const </td></tr>
<tr class="memdesc:a772c46a747904c85ca2b0633ccc77a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest possible descendant distance.  <a href="#a772c46a747904c85ca2b0633ccc77a80">More...</a><br /></td></tr>
<tr class="separator:a772c46a747904c85ca2b0633ccc77a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8b0ef28440c3c991c33240ad0716bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a2a8b0ef28440c3c991c33240ad0716bb">FurthestPointDistance</a> () const </td></tr>
<tr class="memdesc:a2a8b0ef28440c3c991c33240ad0716bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest distance to a point held in this node.  <a href="#a2a8b0ef28440c3c991c33240ad0716bb">More...</a><br /></td></tr>
<tr class="separator:a2a8b0ef28440c3c991c33240ad0716bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c73a40412e85f448542f7facc7bb3"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:ada7c73a40412e85f448542f7facc7bb3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ada7c73a40412e85f448542f7facc7bb3">GetFurthestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:ada7c73a40412e85f448542f7facc7bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query point.  <a href="#ada7c73a40412e85f448542f7facc7bb3">More...</a><br /></td></tr>
<tr class="separator:ada7c73a40412e85f448542f7facc7bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60c2189b3a96791ba5c4557dabe628"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a4d60c2189b3a96791ba5c4557dabe628">GetFurthestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;queryNode) const </td></tr>
<tr class="memdesc:a4d60c2189b3a96791ba5c4557dabe628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query node.  <a href="#a4d60c2189b3a96791ba5c4557dabe628">More...</a><br /></td></tr>
<tr class="separator:a4d60c2189b3a96791ba5c4557dabe628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea304ec71d2a2bc5b00027582f640f6"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a8ea304ec71d2a2bc5b00027582f640f6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a8ea304ec71d2a2bc5b00027582f640f6">GetNearestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:a8ea304ec71d2a2bc5b00027582f640f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query point.  <a href="#a8ea304ec71d2a2bc5b00027582f640f6">More...</a><br /></td></tr>
<tr class="separator:a8ea304ec71d2a2bc5b00027582f640f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e78f3a5f20da8b57298b7ea411c75c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a7e78f3a5f20da8b57298b7ea411c75c5">GetNearestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;queryNode) const </td></tr>
<tr class="memdesc:a7e78f3a5f20da8b57298b7ea411c75c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query node.  <a href="#a7e78f3a5f20da8b57298b7ea411c75c5">More...</a><br /></td></tr>
<tr class="separator:a7e78f3a5f20da8b57298b7ea411c75c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9989ae1ee5feab6660c2659a9624d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a6b9989ae1ee5feab6660c2659a9624d2">IsLeaf</a> () const </td></tr>
<tr class="memdesc:a6b9989ae1ee5feab6660c2659a9624d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not the node is a leaf.  <a href="#a6b9989ae1ee5feab6660c2659a9624d2">More...</a><br /></td></tr>
<tr class="separator:a6b9989ae1ee5feab6660c2659a9624d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9575c0526822aed946176655cc0d55dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a9575c0526822aed946176655cc0d55dc">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;other) const </td></tr>
<tr class="memdesc:a9575c0526822aed946176655cc0d55dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another node.  <a href="#a9575c0526822aed946176655cc0d55dc">More...</a><br /></td></tr>
<tr class="separator:a9575c0526822aed946176655cc0d55dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbc3ebff9cc9322479a7d7ef02566d0"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a3cbc3ebff9cc9322479a7d7ef02566d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a3cbc3ebff9cc9322479a7d7ef02566d0">MaxDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:a3cbc3ebff9cc9322479a7d7ef02566d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to the given point.  <a href="#a3cbc3ebff9cc9322479a7d7ef02566d0">More...</a><br /></td></tr>
<tr class="separator:a3cbc3ebff9cc9322479a7d7ef02566d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a8b24bfa0d12a565ccad5be7e52568"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a84a8b24bfa0d12a565ccad5be7e52568">Metric</a> () const </td></tr>
<tr class="memdesc:a84a8b24bfa0d12a565ccad5be7e52568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the metric that this tree uses.  <a href="#a84a8b24bfa0d12a565ccad5be7e52568">More...</a><br /></td></tr>
<tr class="separator:a84a8b24bfa0d12a565ccad5be7e52568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f3f625fa3e3a468203826c85085dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a749f3f625fa3e3a468203826c85085dd">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;other) const </td></tr>
<tr class="memdesc:a749f3f625fa3e3a468203826c85085dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another node.  <a href="#a749f3f625fa3e3a468203826c85085dd">More...</a><br /></td></tr>
<tr class="separator:a749f3f625fa3e3a468203826c85085dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6055b765a0bca27fd7ed7da2d551b7ee"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a6055b765a0bca27fd7ed7da2d551b7ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a6055b765a0bca27fd7ed7da2d551b7ee">MinDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:a6055b765a0bca27fd7ed7da2d551b7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to the given point.  <a href="#a6055b765a0bca27fd7ed7da2d551b7ee">More...</a><br /></td></tr>
<tr class="separator:a6055b765a0bca27fd7ed7da2d551b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9bf881b541f59ebefc3e2824703124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#adf9bf881b541f59ebefc3e2824703124">MinimumBoundDistance</a> () const </td></tr>
<tr class="memdesc:adf9bf881b541f59ebefc3e2824703124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance from the center of the node to any bound edge.  <a href="#adf9bf881b541f59ebefc3e2824703124">More...</a><br /></td></tr>
<tr class="separator:adf9bf881b541f59ebefc3e2824703124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab879e91583c89af9fe562f568e7f5349"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349">NumChildren</a> () const </td></tr>
<tr class="memdesc:ab879e91583c89af9fe562f568e7f5349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children in this node.  <a href="#ab879e91583c89af9fe562f568e7f5349">More...</a><br /></td></tr>
<tr class="separator:ab879e91583c89af9fe562f568e7f5349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b290d47d99a4f884ca89d7966f3e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a6b3b290d47d99a4f884ca89d7966f3e5">NumDescendants</a> () const </td></tr>
<tr class="memdesc:a6b3b290d47d99a4f884ca89d7966f3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of descendants of this node.  <a href="#a6b3b290d47d99a4f884ca89d7966f3e5">More...</a><br /></td></tr>
<tr class="separator:a6b3b290d47d99a4f884ca89d7966f3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a1afd43d3be69ab9db0255d690307d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a05a1afd43d3be69ab9db0255d690307d">NumPoints</a> () const </td></tr>
<tr class="memdesc:a05a1afd43d3be69ab9db0255d690307d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points in this node (0 if not a leaf).  <a href="#a05a1afd43d3be69ab9db0255d690307d">More...</a><br /></td></tr>
<tr class="separator:a05a1afd43d3be69ab9db0255d690307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639a7dd81cb7201a65060d9f95f0326b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a639a7dd81cb7201a65060d9f95f0326b">Parent</a> () const </td></tr>
<tr class="memdesc:a639a7dd81cb7201a65060d9f95f0326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the parent.  <a href="#a639a7dd81cb7201a65060d9f95f0326b">More...</a><br /></td></tr>
<tr class="separator:a639a7dd81cb7201a65060d9f95f0326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da1659cc848460a36c0b666568c133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ae4da1659cc848460a36c0b666568c133">Parent</a> ()</td></tr>
<tr class="memdesc:ae4da1659cc848460a36c0b666568c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the pointer to the parent (be careful!).  <a href="#ae4da1659cc848460a36c0b666568c133">More...</a><br /></td></tr>
<tr class="separator:ae4da1659cc848460a36c0b666568c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb0a74b9c08fda47fe42b03ab19de8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#acdb0a74b9c08fda47fe42b03ab19de8a">ParentDistance</a> () const </td></tr>
<tr class="memdesc:acdb0a74b9c08fda47fe42b03ab19de8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance from the center of this node to the center of the parent node.  <a href="#acdb0a74b9c08fda47fe42b03ab19de8a">More...</a><br /></td></tr>
<tr class="separator:acdb0a74b9c08fda47fe42b03ab19de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53269198b9ac4e08b9bd67bd7e9ebd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ac53269198b9ac4e08b9bd67bd7e9ebd9">ParentDistance</a> ()</td></tr>
<tr class="memdesc:ac53269198b9ac4e08b9bd67bd7e9ebd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance from the center of this node to the center of the parent node.  <a href="#ac53269198b9ac4e08b9bd67bd7e9ebd9">More...</a><br /></td></tr>
<tr class="separator:ac53269198b9ac4e08b9bd67bd7e9ebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cead53d5ee80b3ec1b931e3156396f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a81cead53d5ee80b3ec1b931e3156396f">Point</a> (const size_t index) const </td></tr>
<tr class="memdesc:a81cead53d5ee80b3ec1b931e3156396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular point in this node.  <a href="#a81cead53d5ee80b3ec1b931e3156396f">More...</a><br /></td></tr>
<tr class="separator:a81cead53d5ee80b3ec1b931e3156396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd6a8ba7835094de8ca5dfe242b389a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aacd6a8ba7835094de8ca5dfe242b389a">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> &amp;other) const </td></tr>
<tr class="memdesc:aacd6a8ba7835094de8ca5dfe242b389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node.  <a href="#aacd6a8ba7835094de8ca5dfe242b389a">More...</a><br /></td></tr>
<tr class="separator:aacd6a8ba7835094de8ca5dfe242b389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a971788819daccc0812e31bbfb0ea0"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:ab8a971788819daccc0812e31bbfb0ea0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab8a971788819daccc0812e31bbfb0ea0">RangeDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:ab8a971788819daccc0812e31bbfb0ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node.  <a href="#ab8a971788819daccc0812e31bbfb0ea0">More...</a><br /></td></tr>
<tr class="separator:ab8a971788819daccc0812e31bbfb0ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7900c808aea6aacc14385dffcfaf874"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:aa7900c808aea6aacc14385dffcfaf874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa7900c808aea6aacc14385dffcfaf874">Serialize</a> (Archive &amp;ar, const unsigned int)</td></tr>
<tr class="memdesc:aa7900c808aea6aacc14385dffcfaf874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the tree.  <a href="#aa7900c808aea6aacc14385dffcfaf874">More...</a><br /></td></tr>
<tr class="separator:aa7900c808aea6aacc14385dffcfaf874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038db1518b7a1447c92f64cff9b72e4a"><td class="memItemLeft" align="right" valign="top">const StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a038db1518b7a1447c92f64cff9b72e4a">Stat</a> () const </td></tr>
<tr class="memdesc:a038db1518b7a1447c92f64cff9b72e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the statistic object for this node.  <a href="#a038db1518b7a1447c92f64cff9b72e4a">More...</a><br /></td></tr>
<tr class="separator:a038db1518b7a1447c92f64cff9b72e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18031eb6e6a2a14837ae29183de2899"><td class="memItemLeft" align="right" valign="top">StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab18031eb6e6a2a14837ae29183de2899">Stat</a> ()</td></tr>
<tr class="memdesc:ab18031eb6e6a2a14837ae29183de2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the statistic object for this node.  <a href="#ab18031eb6e6a2a14837ae29183de2899">More...</a><br /></td></tr>
<tr class="separator:ab18031eb6e6a2a14837ae29183de2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afc1f5a121e694178d4158fd7716a6b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#afc1f5a121e694178d4158fd7716a6b4f">Octree</a> ()</td></tr>
<tr class="memdesc:afc1f5a121e694178d4158fd7716a6b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor.  <a href="#afc1f5a121e694178d4158fd7716a6b4f">More...</a><br /></td></tr>
<tr class="separator:afc1f5a121e694178d4158fd7716a6b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeb73d3863e85eb8ef85eeff881b7b108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aeb73d3863e85eb8ef85eeff881b7b108">SplitNode</a> (const arma::vec &amp;center, const double width, const size_t maxLeafSize)</td></tr>
<tr class="memdesc:aeb73d3863e85eb8ef85eeff881b7b108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the node, using the given center and the given maximum width of this node.  <a href="#aeb73d3863e85eb8ef85eeff881b7b108">More...</a><br /></td></tr>
<tr class="separator:aeb73d3863e85eb8ef85eeff881b7b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb9e4a58e50c4d8bc93424f36bde963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#adcb9e4a58e50c4d8bc93424f36bde963">SplitNode</a> (const arma::vec &amp;center, const double width, std::vector&lt; size_t &gt; &amp;oldFromNew, const size_t maxLeafSize)</td></tr>
<tr class="memdesc:adcb9e4a58e50c4d8bc93424f36bde963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the node, using the given center and the given maximum width of this node, and fill the mappings vector.  <a href="#adcb9e4a58e50c4d8bc93424f36bde963">More...</a><br /></td></tr>
<tr class="separator:adcb9e4a58e50c4d8bc93424f36bde963"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5f314dacb1bbb1ff4f74cb9d24b63617"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5f314dacb1bbb1ff4f74cb9d24b63617">begin</a></td></tr>
<tr class="memdesc:a5f314dacb1bbb1ff4f74cb9d24b63617"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the first point in the dataset contained in this node (and its children).  <a href="#a5f314dacb1bbb1ff4f74cb9d24b63617">More...</a><br /></td></tr>
<tr class="separator:a5f314dacb1bbb1ff4f74cb9d24b63617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5e5c0f12421892bcacff375fee7cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt; MetricType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5d5e5c0f12421892bcacff375fee7cd7">bound</a></td></tr>
<tr class="memdesc:a5d5e5c0f12421892bcacff375fee7cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum bounding rectangle of the points held in the node (and its children).  <a href="#a5d5e5c0f12421892bcacff375fee7cd7">More...</a><br /></td></tr>
<tr class="separator:a5d5e5c0f12421892bcacff375fee7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ade8e1b93a5782227840ecfbc00aaaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a3ade8e1b93a5782227840ecfbc00aaaf">children</a></td></tr>
<tr class="memdesc:a3ade8e1b93a5782227840ecfbc00aaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The children held by this node.  <a href="#a3ade8e1b93a5782227840ecfbc00aaaf">More...</a><br /></td></tr>
<tr class="separator:a3ade8e1b93a5782227840ecfbc00aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5815470a4f5298b047345dbb8bd711b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa5815470a4f5298b047345dbb8bd711b">count</a></td></tr>
<tr class="memdesc:aa5815470a4f5298b047345dbb8bd711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of points of the dataset contained in this node (and its children).  <a href="#aa5815470a4f5298b047345dbb8bd711b">More...</a><br /></td></tr>
<tr class="separator:aa5815470a4f5298b047345dbb8bd711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea450bb883f1930c404c029654abbae"><td class="memItemLeft" align="right" valign="top">MatType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a2ea450bb883f1930c404c029654abbae">dataset</a></td></tr>
<tr class="memdesc:a2ea450bb883f1930c404c029654abbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataset.  <a href="#a2ea450bb883f1930c404c029654abbae">More...</a><br /></td></tr>
<tr class="separator:a2ea450bb883f1930c404c029654abbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a54c76558087afdfc96f85e0e9cdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#af4a54c76558087afdfc96f85e0e9cdcd">furthestDescendantDistance</a></td></tr>
<tr class="memdesc:af4a54c76558087afdfc96f85e0e9cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance to the furthest descendant, cached to speed things up.  <a href="#af4a54c76558087afdfc96f85e0e9cdcd">More...</a><br /></td></tr>
<tr class="separator:af4a54c76558087afdfc96f85e0e9cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca26e60a44923e44de1a233d504464"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a22ca26e60a44923e44de1a233d504464">metric</a></td></tr>
<tr class="memdesc:a22ca26e60a44923e44de1a233d504464"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instantiated metric.  <a href="#a22ca26e60a44923e44de1a233d504464">More...</a><br /></td></tr>
<tr class="separator:a22ca26e60a44923e44de1a233d504464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913f670e041d1fa24fb4a5955e315e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a913f670e041d1fa24fb4a5955e315e73">parent</a></td></tr>
<tr class="memdesc:a913f670e041d1fa24fb4a5955e315e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent (NULL if this node is the root).  <a href="#a913f670e041d1fa24fb4a5955e315e73">More...</a><br /></td></tr>
<tr class="separator:a913f670e041d1fa24fb4a5955e315e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5f136e4408f80d1c569196e7729588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#afd5f136e4408f80d1c569196e7729588">parentDistance</a></td></tr>
<tr class="memdesc:afd5f136e4408f80d1c569196e7729588"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance from the center of this node to the center of the parent.  <a href="#afd5f136e4408f80d1c569196e7729588">More...</a><br /></td></tr>
<tr class="separator:afd5f136e4408f80d1c569196e7729588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18885654ae2a3b93833df415969ca998"><td class="memItemLeft" align="right" valign="top">StatisticType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#a18885654ae2a3b93833df415969ca998">stat</a></td></tr>
<tr class="memdesc:a18885654ae2a3b93833df415969ca998"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statistic.  <a href="#a18885654ae2a3b93833df415969ca998">More...</a><br /></td></tr>
<tr class="separator:a18885654ae2a3b93833df415969ca998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::EuclideanDistance, typename StatisticType = EmptyStatistic, typename MatType = arma::mat&gt;<br />
class mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;</h3>


<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00025">25</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa20764e2edc49b577fa7f243ce126b0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType::elem_type <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of element held in MatType. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00031">31</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b9a63472f0361d4e94500a55ed721ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html#a4b9a63472f0361d4e94500a55ed721ec">Mat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>So other classes can use TreeType::Mat. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00029">29</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3feaf4d7a53d971d351e1e5205decce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This copies the dataset. If you don't want to copy the input dataset, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8e59c56541ff7e11befdf1e731cf61e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This copies the dataset and modifies its ordering; a mapping of the old point indices to the new point indices is filled. If you don't want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adefcee9fb1e53e00d1c265834103fd9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newFromOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This copies the dataset and modifies its ordering; a mapping of the old point indices to the new point indices is filled, and a mapping of the new point indices to the old point indices is filled. If you don't want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std::move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">newFromOld</td><td>Vector which will be filled with the new positions for each old point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a7221d80a2400885d2c4199c443289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This will take ownership of the dataset; if you don't want this, consider using the constructor that takes a const reference to the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac43fa19d1093a9715f26fb286e4f5cea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This will take ownership of the dataset; if you don't want this, consider using the constructor that takes a const reference to the dataset. This modifies the ordering of the dataset; a mapping of the old point indices to the new point indices is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbb535d33b6fc080d1cf9674486fbc9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newFromOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of an octree on the given dataset. </p>
<p>This will take ownership of the dataset; if you don't want this, consider using the constructor that takes a const reference to the dataset. This modifies the ordering of the dataset; a mapping of the old point indices to the new point indices is filled, and a mapping of the new point indices to the old point indices is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. This will be copied! </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">newFromOld</td><td>Vector which will be filled with the new positions for each old point. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fcb94baee247f81f7f521ae7463fdf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, starting at column begin and using count points. </p>
<p>The ordering of that subset of points in the parent's data matrix will be modified! This is used for recursive tree-building by the other constructors that don't specify point indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. Its dataset will be modified! </td></tr>
    <tr><td class="paramname">begin</td><td>Index of point to start tree construction with. </td></tr>
    <tr><td class="paramname">count</td><td>Number of points to use to construct tree. </td></tr>
    <tr><td class="paramname">center</td><td>Center of the node (for splitting). </td></tr>
    <tr><td class="paramname">width</td><td>Width of the node in each dimension. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a241177e4530ce48059c397bfb49dafbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, starting at column begin and using count points. </p>
<p>The ordering of that subset of points in the parent's data matrix will be modified! This is used for recursive tree-building by the other constructors that don't specify point indices.</p>
<p>A mapping of the old point indices to the new point indices is filled, but it is expected that the vector is already allocated with size greater than or equal to (begin + count), and if that is not true, invalid memory reads (and writes) will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. Its dataset will be modified! </td></tr>
    <tr><td class="paramname">begin</td><td>Index of point to start tree construction with. </td></tr>
    <tr><td class="paramname">count</td><td>Number of points to use to construct tree. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Vector which will be filled with the old positions for each new point. </td></tr>
    <tr><td class="paramname">center</td><td>Center of the node (for splitting). </td></tr>
    <tr><td class="paramname">width</td><td>Width of the node in each dimension. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points in a leaf node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b4833f2f942eeb03746903b6735b29f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given tree. </p>
<p>Be careful! This may use a lot of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Tree to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e67aa2ce3e3a83f035227be6229b4db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the given tree. </p>
<p>The tree passed as a parameter will be emptied and will not be usable after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Tree to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a0258ddedb29bff08e2bf4a715fe5f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; Archive::is_loading::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the tree from a <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Archive to load tree from. Must be an iarchive, not an oarchive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8da105a7834635cc14ee186325beb0f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::~<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the tree. </p>

</div>
</div>
<a class="anchor" id="afc1f5a121e694178d4158fd7716a6b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor. </p>
<p>This is meant to only be used with <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a>, which is allowed with the friend declaration below. This does not return a valid treee! The method must be protected, so that the serialization shim can work with the default constructor. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00383">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Center()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a452cb2f0b6c58bb2436a01ac7927e327"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt;MetricType&gt;&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bound object for this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00247">247</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00053">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::bound</a>.</p>

</div>
</div>
<a class="anchor" id="aae7da5f4423534574566ce01bc3c3f32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt;MetricType&gt;&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the bound object for this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00249">249</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00053">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::bound</a>.</p>

</div>
</div>
<a class="anchor" id="af210624bc714be08f915cda078aec311"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Center </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the center of the bounding region in the given vector. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00383">383</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1bound_1_1HRectBound.html#ab1b554dff9988b1cb42ddf56ac0b50c4">mlpack::bound::HRectBound&lt; MetricType, ElemType &gt;::Center()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#afc1f5a121e694178d4158fd7716a6b4f">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Octree()</a>, and <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa7900c808aea6aacc14385dffcfaf874">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ad695fa4f5c07257043836b2c314caca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified child. </p>
<p>If the index is out of bounds, unspecified behavior will occur. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00326">326</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19ba544daa39ca1308d5a40fe63214f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified child. </p>
<p>If the index is out of bounds, unspecified behavior will occur. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00332">332</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a822be90e25c3a9ffdc2b25aa3c96b8bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::ChildPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the pointer to the given child. </p>
<p>This allows the child itself to be modified. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00338">338</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a5297ae382946af49d5dea20d13ea6da2">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Descendant()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a9575c0526822aed946176655cc0d55dc">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::MaxDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a749f3f625fa3e3a468203826c85085dd">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::MinDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a6b3b290d47d99a4f884ca89d7966f3e5">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::NumDescendants()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a05a1afd43d3be69ab9db0255d690307d">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::NumPoints()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a81cead53d5ee80b3ec1b931e3156396f">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Point()</a>, and <a class="el" href="classmlpack_1_1tree_1_1Octree.html#aacd6a8ba7835094de8ca5dfe242b389a">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::RangeDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a57220daa8b49ffd341441976fe6a3942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dataset used by this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00239">239</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00055">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::dataset</a>.</p>

</div>
</div>
<a class="anchor" id="a5297ae382946af49d5dea20d13ea6da2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Descendant </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular descendant. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a772c46a747904c85ca2b0633ccc77a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::FurthestDescendantDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest possible descendant distance. </p>
<p>This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a8b0ef28440c3c991c33240ad0716bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::FurthestPointDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest distance to a point held in this node. </p>
<p>If this is not a leaf node, then the distance is 0 because the node holds no points. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="ada7c73a40412e85f448542f7facc7bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>, and <a class="el" href="octree_2octree_8hpp_source.html#l00260">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d60c2189b3a96791ba5c4557dabe628"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a class="anchor" id="a8ea304ec71d2a2bc5b00027582f640f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>, and <a class="el" href="octree_2octree_8hpp_source.html#l00260">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e78f3a5f20da8b57298b7ea411c75c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a class="anchor" id="a6b9989ae1ee5feab6660c2659a9624d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::IsLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether or not the node is a leaf. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00283">283</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a772c46a747904c85ca2b0633ccc77a80">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::FurthestDescendantDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a2a8b0ef28440c3c991c33240ad0716bb">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::FurthestPointDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ada7c73a40412e85f448542f7facc7bb3">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::GetFurthestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a8ea304ec71d2a2bc5b00027582f640f6">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::GetNearestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1Octree.html#adf9bf881b541f59ebefc3e2824703124">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::MinimumBoundDistance()</a>, and <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::NumChildren()</a>.</p>

</div>
</div>
<a class="anchor" id="a9575c0526822aed946176655cc0d55dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to another node. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cbc3ebff9cc9322479a7d7ef02566d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to the given point. </p>

</div>
</div>
<a class="anchor" id="a84a8b24bfa0d12a565ccad5be7e52568"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the metric that this tree uses. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00260">260</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ada7c73a40412e85f448542f7facc7bb3">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::GetFurthestChild()</a>, and <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a8ea304ec71d2a2bc5b00027582f640f6">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::GetNearestChild()</a>.</p>

</div>
</div>
<a class="anchor" id="a749f3f625fa3e3a468203826c85085dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::MinDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to another node. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a6055b765a0bca27fd7ed7da2d551b7ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::MinDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to the given point. </p>

</div>
</div>
<a class="anchor" id="adf9bf881b541f59ebefc3e2824703124"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::MinimumBoundDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance from the center of the node to any bound edge. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>.</p>

</div>
</div>
<a class="anchor" id="ab879e91583c89af9fe562f568e7f5349"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::NumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of children in this node. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00283">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::IsLeaf()</a>, and <a class="el" href="octree_2octree_8hpp_source.html#l00254">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Stat()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b3b290d47d99a4f884ca89d7966f3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::NumDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of descendants of this node. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a05a1afd43d3be69ab9db0255d690307d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::NumPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of points in this node (0 if not a leaf). </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a639a7dd81cb7201a65060d9f95f0326b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>* <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer to the parent. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00242">242</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00057">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::parent</a>.</p>

</div>
</div>
<a class="anchor" id="ae4da1659cc848460a36c0b666568c133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the pointer to the parent (be careful!). </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00244">244</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00057">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::parent</a>.</p>

</div>
</div>
<a class="anchor" id="acdb0a74b9c08fda47fe42b03ab19de8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance from the center of this node to the center of the parent node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00317">317</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00061">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::parentDistance</a>.</p>

</div>
</div>
<a class="anchor" id="ac53269198b9ac4e08b9bd67bd7e9ebd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance from the center of this node to the center of the parent node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00320">320</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00061">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::parentDistance</a>.</p>

</div>
</div>
<a class="anchor" id="a81cead53d5ee80b3ec1b931e3156396f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Point </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular point in this node. </p>
<p>If the given index is invalid (i.e. if it is greater than <a class="el" href="classmlpack_1_1tree_1_1Octree.html#a05a1afd43d3be69ab9db0255d690307d" title="Return the number of points in this node (0 if not a leaf). ">NumPoints()</a>), the indices returned will be invalid. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="aacd6a8ba7835094de8ca5dfe242b389a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&gt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>&lt; MetricType, StatisticType, MatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00338">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a971788819daccc0812e31bbfb0ea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a>&gt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node. </p>

</div>
</div>
<a class="anchor" id="aa7900c808aea6aacc14385dffcfaf874"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the tree. </p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00383">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Center()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb73d3863e85eb8ef85eeff881b7b108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::SplitNode </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the node, using the given center and the given maximum width of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the node. </td></tr>
    <tr><td class="paramname">width</td><td>Width of the current node. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points allowed in a leaf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcb9e4a58e50c4d8bc93424f36bde963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::SplitNode </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldFromNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the node, using the given center and the given maximum width of this node, and fill the mappings vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the node. </td></tr>
    <tr><td class="paramname">width</td><td>Width of the current node. </td></tr>
    <tr><td class="paramname">oldFromNew</td><td>Mappings from old to new. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points allowed in a leaf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a038db1518b7a1447c92f64cff9b72e4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the statistic object for this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00252">252</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="octree_2octree_8hpp_source.html#l00059">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::stat</a>.</p>

</div>
</div>
<a class="anchor" id="ab18031eb6e6a2a14837ae29183de2899"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the statistic object for this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00254">254</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1Octree.html#ab879e91583c89af9fe562f568e7f5349">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::NumChildren()</a>, and <a class="el" href="octree_2octree_8hpp_source.html#l00059">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::stat</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5f314dacb1bbb1ff4f74cb9d24b63617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index of the first point in the dataset contained in this node (and its children). </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00047">47</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5e5c0f12421892bcacff375fee7cd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1bound_1_1HRectBound.html">bound::HRectBound</a>&lt;MetricType&gt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::bound</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum bounding rectangle of the points held in the node (and its children). </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00053">53</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00247">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ade8e1b93a5782227840ecfbc00aaaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>*&gt; <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The children held by this node. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00039">39</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5815470a4f5298b047345dbb8bd711b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of points of the dataset contained in this node (and its children). </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00050">50</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ea450bb883f1930c404c029654abbae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatType* <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::dataset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dataset. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00055">55</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00239">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Dataset()</a>.</p>

</div>
</div>
<a class="anchor" id="af4a54c76558087afdfc96f85e0e9cdcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::furthestDescendantDistance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The distance to the furthest descendant, cached to speed things up. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00063">63</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22ca26e60a44923e44de1a233d504464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instantiated metric. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00065">65</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a913f670e041d1fa24fb4a5955e315e73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html">Octree</a>* <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parent (NULL if this node is the root). </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00057">57</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00242">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Parent()</a>.</p>

</div>
</div>
<a class="anchor" id="afd5f136e4408f80d1c569196e7729588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1Octree.html#aa20764e2edc49b577fa7f243ce126b0b">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::parentDistance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The distance from the center of this node to the center of the parent. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00061">61</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00317">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::ParentDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a18885654ae2a3b93833df415969ca998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::EuclideanDistance, typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType <a class="el" href="classmlpack_1_1tree_1_1Octree.html">mlpack::tree::Octree</a>&lt; MetricType, StatisticType, MatType &gt;::stat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The statistic. </p>

<p>Definition at line <a class="el" href="octree_2octree_8hpp_source.html#l00059">59</a> of file <a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a>.</p>

<p>Referenced by <a class="el" href="octree_2octree_8hpp_source.html#l00252">mlpack::tree::Octree&lt; MetricType, StatisticType, MatType &gt;::Stat()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/core/tree/octree/<a class="el" href="octree_2octree_8hpp_source.html">octree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
<script type="text/javascript">
var x = document.getElementsByClassName("formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width /= 4;
}
</script>
</html>
