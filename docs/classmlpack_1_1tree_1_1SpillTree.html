<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mlpack: mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmlpack_1_1tree_1_1SpillTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A hybrid spill tree is a variant of binary space trees in which the children of a node can "spill over" each other, and contain shared datapoints.  
 <a href="classmlpack_1_1tree_1_1SpillTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html">SpillDualTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic dual-tree traverser for hybrid spill trees; see <a class="el" href="spill__dual__tree__traverser_8hpp.html">spill_dual_tree_traverser.hpp</a> for implementation.  <a href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html">SpillSingleTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic single-tree traverser for hybrid spill trees; see <a class="el" href="spill__single__tree__traverser_8hpp.html">spill_single_tree_traverser.hpp</a> for implementation.  <a href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17fd81b3578ad9c1ba2c21bf8590319d"><td class="memItemLeft" align="right" valign="top">typedef HyperplaneType&lt; MetricType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a></td></tr>
<tr class="memdesc:a17fd81b3578ad9c1ba2c21bf8590319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bound type.  <a href="#a17fd81b3578ad9c1ba2c21bf8590319d">More...</a><br /></td></tr>
<tr class="separator:a17fd81b3578ad9c1ba2c21bf8590319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407ac8fa6f6a73ed61c755933f64ace2"><td class="memTemplParams" colspan="2">template&lt;typename RuleType &gt; </td></tr>
<tr class="memitem:a407ac8fa6f6a73ed61c755933f64ace2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a407ac8fa6f6a73ed61c755933f64ace2">DefeatistDualTreeTraverser</a> = <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html">SpillDualTreeTraverser</a>&lt; RuleType, true &gt;</td></tr>
<tr class="memdesc:a407ac8fa6f6a73ed61c755933f64ace2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A defeatist dual-tree traverser for hybrid spill trees.  <a href="#a407ac8fa6f6a73ed61c755933f64ace2">More...</a><br /></td></tr>
<tr class="separator:a407ac8fa6f6a73ed61c755933f64ace2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1fd43e08b5a226c1daab98efba83d"><td class="memTemplParams" colspan="2">template&lt;typename RuleType &gt; </td></tr>
<tr class="memitem:aaae1fd43e08b5a226c1daab98efba83d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aaae1fd43e08b5a226c1daab98efba83d">DefeatistSingleTreeTraverser</a> = <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html">SpillSingleTreeTraverser</a>&lt; RuleType, true &gt;</td></tr>
<tr class="memdesc:aaae1fd43e08b5a226c1daab98efba83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A defeatist single-tree traverser for hybrid spill trees.  <a href="#aaae1fd43e08b5a226c1daab98efba83d">More...</a><br /></td></tr>
<tr class="separator:aaae1fd43e08b5a226c1daab98efba83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776c82e8b9d3711dcfdc1e7633c30306"><td class="memTemplParams" colspan="2">template&lt;typename RuleType &gt; </td></tr>
<tr class="memitem:a776c82e8b9d3711dcfdc1e7633c30306"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a776c82e8b9d3711dcfdc1e7633c30306">DualTreeTraverser</a> = <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html">SpillDualTreeTraverser</a>&lt; RuleType, false &gt;</td></tr>
<tr class="memdesc:a776c82e8b9d3711dcfdc1e7633c30306"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual-tree traverser for hybrid spill trees.  <a href="#a776c82e8b9d3711dcfdc1e7633c30306">More...</a><br /></td></tr>
<tr class="separator:a776c82e8b9d3711dcfdc1e7633c30306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5698c45a888029b584108bdc943700af"><td class="memItemLeft" align="right" valign="top">typedef MatType::elem_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a></td></tr>
<tr class="memdesc:a5698c45a888029b584108bdc943700af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of element held in MatType.  <a href="#a5698c45a888029b584108bdc943700af">More...</a><br /></td></tr>
<tr class="separator:a5698c45a888029b584108bdc943700af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b11ae05884a921d378e734922f8653"><td class="memItemLeft" align="right" valign="top">typedef MatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ab0b11ae05884a921d378e734922f8653">Mat</a></td></tr>
<tr class="memdesc:ab0b11ae05884a921d378e734922f8653"><td class="mdescLeft">&#160;</td><td class="mdescRight">So other classes can use TreeType::Mat.  <a href="#ab0b11ae05884a921d378e734922f8653">More...</a><br /></td></tr>
<tr class="separator:ab0b11ae05884a921d378e734922f8653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b7fc2ba94d53eaf705541b7fe99a30"><td class="memTemplParams" colspan="2">template&lt;typename RuleType &gt; </td></tr>
<tr class="memitem:a02b7fc2ba94d53eaf705541b7fe99a30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a02b7fc2ba94d53eaf705541b7fe99a30">SingleTreeTraverser</a> = <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html">SpillSingleTreeTraverser</a>&lt; RuleType, false &gt;</td></tr>
<tr class="memdesc:a02b7fc2ba94d53eaf705541b7fe99a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-tree traverser for hybrid spill trees.  <a href="#a02b7fc2ba94d53eaf705541b7fe99a30">More...</a><br /></td></tr>
<tr class="separator:a02b7fc2ba94d53eaf705541b7fe99a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac96f40b48753be633942e0aa199c2696"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ac96f40b48753be633942e0aa199c2696">SpillTree</a> (const MatType &amp;data, const double tau=0, const size_t maxLeafSize=20, const double rho=0.7)</td></tr>
<tr class="memdesc:ac96f40b48753be633942e0aa199c2696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a hybrid spill tree using the given dataset.  <a href="#ac96f40b48753be633942e0aa199c2696">More...</a><br /></td></tr>
<tr class="separator:ac96f40b48753be633942e0aa199c2696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80a9b70c117d80e0d6578cf309726b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a4d80a9b70c117d80e0d6578cf309726b">SpillTree</a> (MatType &amp;&amp;data, const double tau=0, const size_t maxLeafSize=20, const double rho=0.7)</td></tr>
<tr class="memdesc:a4d80a9b70c117d80e0d6578cf309726b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this as the root node of a hybrid spill tree using the given dataset.  <a href="#a4d80a9b70c117d80e0d6578cf309726b">More...</a><br /></td></tr>
<tr class="separator:a4d80a9b70c117d80e0d6578cf309726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0eb4c71bd9f14f268bc7d308e69df7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a8c0eb4c71bd9f14f268bc7d308e69df7">SpillTree</a> (<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5cd7de5c98bd88b4dfbee977e05c9c3b">parent</a>, arma::Col&lt; size_t &gt; &amp;points, const double tau=0, const size_t maxLeafSize=20, const double rho=0.7)</td></tr>
<tr class="memdesc:a8c0eb4c71bd9f14f268bc7d308e69df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this node as a child of the given parent, including the given list of points.  <a href="#a8c0eb4c71bd9f14f268bc7d308e69df7">More...</a><br /></td></tr>
<tr class="separator:a8c0eb4c71bd9f14f268bc7d308e69df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523681f12549e5c5d622cfaf833c706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a8523681f12549e5c5d622cfaf833c706">SpillTree</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;other)</td></tr>
<tr class="memdesc:a8523681f12549e5c5d622cfaf833c706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hybrid spill tree by copying the other tree.  <a href="#a8523681f12549e5c5d622cfaf833c706">More...</a><br /></td></tr>
<tr class="separator:a8523681f12549e5c5d622cfaf833c706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813d9ca5876687d6069518beffbdfe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ad813d9ca5876687d6069518beffbdfe1">SpillTree</a> (<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ad813d9ca5876687d6069518beffbdfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for a <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html" title="A hybrid spill tree is a variant of binary space trees in which the children of a node can &quot;spill ove...">SpillTree</a>; possess all the members of the given tree.  <a href="#ad813d9ca5876687d6069518beffbdfe1">More...</a><br /></td></tr>
<tr class="separator:ad813d9ca5876687d6069518beffbdfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ebc56b812906568182cf1b8402e7b5"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a55ebc56b812906568182cf1b8402e7b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a55ebc56b812906568182cf1b8402e7b5">SpillTree</a> (Archive &amp;ar, const typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; Archive::is_loading::value &gt; *=0)</td></tr>
<tr class="memdesc:a55ebc56b812906568182cf1b8402e7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the tree from a <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> archive.  <a href="#a55ebc56b812906568182cf1b8402e7b5">More...</a><br /></td></tr>
<tr class="separator:a55ebc56b812906568182cf1b8402e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a25250eb841f4144bb235e32299a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#af9a25250eb841f4144bb235e32299a02">~SpillTree</a> ()</td></tr>
<tr class="memdesc:af9a25250eb841f4144bb235e32299a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes this node, deallocating the memory for the children and calling their destructors in turn.  <a href="#af9a25250eb841f4144bb235e32299a02">More...</a><br /></td></tr>
<tr class="separator:af9a25250eb841f4144bb235e32299a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284c6e2186de53946f5ba5906bfbec85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a284c6e2186de53946f5ba5906bfbec85">Bound</a> () const </td></tr>
<tr class="memdesc:a284c6e2186de53946f5ba5906bfbec85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bound object for this node.  <a href="#a284c6e2186de53946f5ba5906bfbec85">More...</a><br /></td></tr>
<tr class="separator:a284c6e2186de53946f5ba5906bfbec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af02115e7005043125d967e5cb7c7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a9af02115e7005043125d967e5cb7c7f6">Bound</a> ()</td></tr>
<tr class="memdesc:a9af02115e7005043125d967e5cb7c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bound object for this node.  <a href="#a9af02115e7005043125d967e5cb7c7f6">More...</a><br /></td></tr>
<tr class="separator:a9af02115e7005043125d967e5cb7c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e896b966e7cd965b06954c83b911ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a6e896b966e7cd965b06954c83b911ff1">Center</a> (arma::vec &amp;center)</td></tr>
<tr class="memdesc:a6e896b966e7cd965b06954c83b911ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the center of the bounding region in the given vector.  <a href="#a6e896b966e7cd965b06954c83b911ff1">More...</a><br /></td></tr>
<tr class="separator:a6e896b966e7cd965b06954c83b911ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22ba4810151bbe4fa884190e199d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a3e22ba4810151bbe4fa884190e199d92">Child</a> (const size_t child) const </td></tr>
<tr class="memdesc:a3e22ba4810151bbe4fa884190e199d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified child (0 will be left, 1 will be right).  <a href="#a3e22ba4810151bbe4fa884190e199d92">More...</a><br /></td></tr>
<tr class="separator:a3e22ba4810151bbe4fa884190e199d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02faee35dd9e74c8b9f4b4691579d4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a02faee35dd9e74c8b9f4b4691579d4c1">ChildPtr</a> (const size_t child)</td></tr>
<tr class="separator:a02faee35dd9e74c8b9f4b4691579d4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247403cd94290da5dd752f5a77c4aee9"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a247403cd94290da5dd752f5a77c4aee9">Dataset</a> () const </td></tr>
<tr class="memdesc:a247403cd94290da5dd752f5a77c4aee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dataset which the tree is built on.  <a href="#a247403cd94290da5dd752f5a77c4aee9">More...</a><br /></td></tr>
<tr class="separator:a247403cd94290da5dd752f5a77c4aee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae241a75ccb0f50802b64143c35f71a03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ae241a75ccb0f50802b64143c35f71a03">Descendant</a> (const size_t index) const </td></tr>
<tr class="memdesc:ae241a75ccb0f50802b64143c35f71a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular descendant of this node.  <a href="#ae241a75ccb0f50802b64143c35f71a03">More...</a><br /></td></tr>
<tr class="separator:ae241a75ccb0f50802b64143c35f71a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64b2b9ca6117b3cf89c41a80b278532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#af64b2b9ca6117b3cf89c41a80b278532">FurthestDescendantDistance</a> () const </td></tr>
<tr class="memdesc:af64b2b9ca6117b3cf89c41a80b278532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest possible descendant distance.  <a href="#af64b2b9ca6117b3cf89c41a80b278532">More...</a><br /></td></tr>
<tr class="separator:af64b2b9ca6117b3cf89c41a80b278532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe3ee7cd1b1b77a6b4291d473059e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#acfbe3ee7cd1b1b77a6b4291d473059e8">FurthestPointDistance</a> () const </td></tr>
<tr class="memdesc:acfbe3ee7cd1b1b77a6b4291d473059e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the furthest distance to a point held in this node.  <a href="#acfbe3ee7cd1b1b77a6b4291d473059e8">More...</a><br /></td></tr>
<tr class="separator:acfbe3ee7cd1b1b77a6b4291d473059e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d748e559c8ac083cd5803a0aaffc354"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a7d748e559c8ac083cd5803a0aaffc354"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a7d748e559c8ac083cd5803a0aaffc354">GetFurthestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a7d748e559c8ac083cd5803a0aaffc354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest).  <a href="#a7d748e559c8ac083cd5803a0aaffc354">More...</a><br /></td></tr>
<tr class="separator:a7d748e559c8ac083cd5803a0aaffc354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2f70ae3392aa7eaa412ddffee6034d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a0f2f70ae3392aa7eaa412ddffee6034d">GetFurthestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:a0f2f70ae3392aa7eaa412ddffee6034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest).  <a href="#a0f2f70ae3392aa7eaa412ddffee6034d">More...</a><br /></td></tr>
<tr class="separator:a0f2f70ae3392aa7eaa412ddffee6034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66015f3c1d1c981b38baee9867e05330"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a66015f3c1d1c981b38baee9867e05330"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a66015f3c1d1c981b38baee9867e05330">GetNearestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a66015f3c1d1c981b38baee9867e05330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest).  <a href="#a66015f3c1d1c981b38baee9867e05330">More...</a><br /></td></tr>
<tr class="separator:a66015f3c1d1c981b38baee9867e05330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50785371927a61d7236b8ae962de4d87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a50785371927a61d7236b8ae962de4d87">GetNearestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:a50785371927a61d7236b8ae962de4d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest).  <a href="#a50785371927a61d7236b8ae962de4d87">More...</a><br /></td></tr>
<tr class="separator:a50785371927a61d7236b8ae962de4d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e18c815ff2459feab39e6b4b8795fd"><td class="memItemLeft" align="right" valign="top">const HyperplaneType&lt; MetricType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a49e18c815ff2459feab39e6b4b8795fd">Hyperplane</a> () const </td></tr>
<tr class="memdesc:a49e18c815ff2459feab39e6b4b8795fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Hyperplane instance.  <a href="#a49e18c815ff2459feab39e6b4b8795fd">More...</a><br /></td></tr>
<tr class="separator:a49e18c815ff2459feab39e6b4b8795fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1992b8610849049501a0f39cce136d51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a1992b8610849049501a0f39cce136d51">IsLeaf</a> () const </td></tr>
<tr class="memdesc:a1992b8610849049501a0f39cce136d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not this node is a leaf (true if it has no children).  <a href="#a1992b8610849049501a0f39cce136d51">More...</a><br /></td></tr>
<tr class="separator:a1992b8610849049501a0f39cce136d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aa14bd2cb0ab2a5059781f290ec88b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ac0aa14bd2cb0ab2a5059781f290ec88b">Left</a> () const </td></tr>
<tr class="memdesc:ac0aa14bd2cb0ab2a5059781f290ec88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the left child of this node.  <a href="#ac0aa14bd2cb0ab2a5059781f290ec88b">More...</a><br /></td></tr>
<tr class="separator:ac0aa14bd2cb0ab2a5059781f290ec88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc5932a9fdc72e8eaea4b6b478a968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a9fbc5932a9fdc72e8eaea4b6b478a968">Left</a> ()</td></tr>
<tr class="memdesc:a9fbc5932a9fdc72e8eaea4b6b478a968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the left child of this node.  <a href="#a9fbc5932a9fdc72e8eaea4b6b478a968">More...</a><br /></td></tr>
<tr class="separator:a9fbc5932a9fdc72e8eaea4b6b478a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532a790cb96a882c5cf96a2e1f07d2f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a532a790cb96a882c5cf96a2e1f07d2f8">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;other) const </td></tr>
<tr class="memdesc:a532a790cb96a882c5cf96a2e1f07d2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another node.  <a href="#a532a790cb96a882c5cf96a2e1f07d2f8">More...</a><br /></td></tr>
<tr class="separator:a532a790cb96a882c5cf96a2e1f07d2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa541b880f75f73d0bfd3b4da8fc12c96"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:aa541b880f75f73d0bfd3b4da8fc12c96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aa541b880f75f73d0bfd3b4da8fc12c96">MaxDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:aa541b880f75f73d0bfd3b4da8fc12c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another point.  <a href="#aa541b880f75f73d0bfd3b4da8fc12c96">More...</a><br /></td></tr>
<tr class="separator:aa541b880f75f73d0bfd3b4da8fc12c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac1e93b1d7fad7a472cb689d9b7b93f"><td class="memItemLeft" align="right" valign="top">MetricType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a6ac1e93b1d7fad7a472cb689d9b7b93f">Metric</a> () const </td></tr>
<tr class="memdesc:a6ac1e93b1d7fad7a472cb689d9b7b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metric that the tree uses.  <a href="#a6ac1e93b1d7fad7a472cb689d9b7b93f">More...</a><br /></td></tr>
<tr class="separator:a6ac1e93b1d7fad7a472cb689d9b7b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6b18234af0f93400a8bf3dbf85d572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aff6b18234af0f93400a8bf3dbf85d572">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;other) const </td></tr>
<tr class="memdesc:aff6b18234af0f93400a8bf3dbf85d572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another node.  <a href="#aff6b18234af0f93400a8bf3dbf85d572">More...</a><br /></td></tr>
<tr class="separator:aff6b18234af0f93400a8bf3dbf85d572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858cfecadd0072283606c9f44b2031c9"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a858cfecadd0072283606c9f44b2031c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a858cfecadd0072283606c9f44b2031c9">MinDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:a858cfecadd0072283606c9f44b2031c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another point.  <a href="#a858cfecadd0072283606c9f44b2031c9">More...</a><br /></td></tr>
<tr class="separator:a858cfecadd0072283606c9f44b2031c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0721e0735177434b262293cefb19e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a1a0721e0735177434b262293cefb19e3">MinimumBoundDistance</a> () const </td></tr>
<tr class="memdesc:a1a0721e0735177434b262293cefb19e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance from the center of the node to any bound edge.  <a href="#a1a0721e0735177434b262293cefb19e3">More...</a><br /></td></tr>
<tr class="separator:a1a0721e0735177434b262293cefb19e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20190e12a6b9c7ab7c52f73b516bb3bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf">NumChildren</a> () const </td></tr>
<tr class="memdesc:a20190e12a6b9c7ab7c52f73b516bb3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children in this node.  <a href="#a20190e12a6b9c7ab7c52f73b516bb3bf">More...</a><br /></td></tr>
<tr class="separator:a20190e12a6b9c7ab7c52f73b516bb3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330791a347eadf429808ef4fb4f5e0d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a330791a347eadf429808ef4fb4f5e0d8">NumDescendants</a> () const </td></tr>
<tr class="memdesc:a330791a347eadf429808ef4fb4f5e0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of descendants of this node.  <a href="#a330791a347eadf429808ef4fb4f5e0d8">More...</a><br /></td></tr>
<tr class="separator:a330791a347eadf429808ef4fb4f5e0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b30aac8ab1016393544e13382de438"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a94b30aac8ab1016393544e13382de438">NumPoints</a> () const </td></tr>
<tr class="memdesc:a94b30aac8ab1016393544e13382de438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points in this node (0 if not a leaf).  <a href="#a94b30aac8ab1016393544e13382de438">More...</a><br /></td></tr>
<tr class="separator:a94b30aac8ab1016393544e13382de438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee7d736b7d529587a23f7379fbed76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a6fee7d736b7d529587a23f7379fbed76">Overlap</a> () const </td></tr>
<tr class="memdesc:a6fee7d736b7d529587a23f7379fbed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distinguish overlapping nodes from non-overlapping nodes.  <a href="#a6fee7d736b7d529587a23f7379fbed76">More...</a><br /></td></tr>
<tr class="separator:a6fee7d736b7d529587a23f7379fbed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c4368a28681f0b9b6b8240cae9a85c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ab0c4368a28681f0b9b6b8240cae9a85c">Parent</a> () const </td></tr>
<tr class="memdesc:ab0c4368a28681f0b9b6b8240cae9a85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent of this node.  <a href="#ab0c4368a28681f0b9b6b8240cae9a85c">More...</a><br /></td></tr>
<tr class="separator:ab0c4368a28681f0b9b6b8240cae9a85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d4e02e3f2044fa692a508b4f52602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ad28d4e02e3f2044fa692a508b4f52602">Parent</a> ()</td></tr>
<tr class="memdesc:ad28d4e02e3f2044fa692a508b4f52602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the parent of this node.  <a href="#ad28d4e02e3f2044fa692a508b4f52602">More...</a><br /></td></tr>
<tr class="separator:ad28d4e02e3f2044fa692a508b4f52602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90011a35463b64ac7e11f53a1e1e3160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a90011a35463b64ac7e11f53a1e1e3160">ParentDistance</a> () const </td></tr>
<tr class="memdesc:a90011a35463b64ac7e11f53a1e1e3160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance from the center of this node to the center of the parent node.  <a href="#a90011a35463b64ac7e11f53a1e1e3160">More...</a><br /></td></tr>
<tr class="separator:a90011a35463b64ac7e11f53a1e1e3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efc45482288c77246cd7c71e64a7de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a1efc45482288c77246cd7c71e64a7de6">ParentDistance</a> ()</td></tr>
<tr class="memdesc:a1efc45482288c77246cd7c71e64a7de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance from the center of this node to the center of the parent node.  <a href="#a1efc45482288c77246cd7c71e64a7de6">More...</a><br /></td></tr>
<tr class="separator:a1efc45482288c77246cd7c71e64a7de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f650191492eee6c5bd4c53d4fe6dd8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a69f650191492eee6c5bd4c53d4fe6dd8">Point</a> (const size_t index) const </td></tr>
<tr class="memdesc:a69f650191492eee6c5bd4c53d4fe6dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index (with reference to the dataset) of a particular point in this node.  <a href="#a69f650191492eee6c5bd4c53d4fe6dd8">More...</a><br /></td></tr>
<tr class="separator:a69f650191492eee6c5bd4c53d4fe6dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b673b990e6453cee38476b6c62c703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ab2b673b990e6453cee38476b6c62c703">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> &amp;other) const </td></tr>
<tr class="memdesc:ab2b673b990e6453cee38476b6c62c703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node.  <a href="#ab2b673b990e6453cee38476b6c62c703">More...</a><br /></td></tr>
<tr class="separator:ab2b673b990e6453cee38476b6c62c703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b075950256b6f058e459644f1fbdae2"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a7b075950256b6f058e459644f1fbdae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a7b075950256b6f058e459644f1fbdae2">RangeDistance</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0) const </td></tr>
<tr class="memdesc:a7b075950256b6f058e459644f1fbdae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another point.  <a href="#a7b075950256b6f058e459644f1fbdae2">More...</a><br /></td></tr>
<tr class="separator:a7b075950256b6f058e459644f1fbdae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3accade12965b3fa514e1fe5f0d8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a7e3accade12965b3fa514e1fe5f0d8a2">Right</a> () const </td></tr>
<tr class="memdesc:a7e3accade12965b3fa514e1fe5f0d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the right child of this node.  <a href="#a7e3accade12965b3fa514e1fe5f0d8a2">More...</a><br /></td></tr>
<tr class="separator:a7e3accade12965b3fa514e1fe5f0d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46375a4336e0fef8c52821e5029926f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a46375a4336e0fef8c52821e5029926f0">Right</a> ()</td></tr>
<tr class="memdesc:a46375a4336e0fef8c52821e5029926f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the right child of this node.  <a href="#a46375a4336e0fef8c52821e5029926f0">More...</a><br /></td></tr>
<tr class="separator:a46375a4336e0fef8c52821e5029926f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6897e914aad2bdfb8328c1ccaf4c65e1"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a6897e914aad2bdfb8328c1ccaf4c65e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a6897e914aad2bdfb8328c1ccaf4c65e1">Serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="memdesc:a6897e914aad2bdfb8328c1ccaf4c65e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the tree.  <a href="#a6897e914aad2bdfb8328c1ccaf4c65e1">More...</a><br /></td></tr>
<tr class="separator:a6897e914aad2bdfb8328c1ccaf4c65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07864908e6a19c4ae69a837a8fadd993"><td class="memItemLeft" align="right" valign="top">const StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a07864908e6a19c4ae69a837a8fadd993">Stat</a> () const </td></tr>
<tr class="memdesc:a07864908e6a19c4ae69a837a8fadd993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the statistic object for this node.  <a href="#a07864908e6a19c4ae69a837a8fadd993">More...</a><br /></td></tr>
<tr class="separator:a07864908e6a19c4ae69a837a8fadd993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea9e6f62544ec7d08297113f885d923"><td class="memItemLeft" align="right" valign="top">StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#afea9e6f62544ec7d08297113f885d923">Stat</a> ()</td></tr>
<tr class="memdesc:afea9e6f62544ec7d08297113f885d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the statistic object for this node.  <a href="#afea9e6f62544ec7d08297113f885d923">More...</a><br /></td></tr>
<tr class="separator:afea9e6f62544ec7d08297113f885d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af1ec0e9ad1d695c404d6bfc3f40072cc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#af1ec0e9ad1d695c404d6bfc3f40072cc">HasSelfChildren</a> ()</td></tr>
<tr class="memdesc:af1ec0e9ad1d695c404d6bfc3f40072cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false: this tree type does not have self children.  <a href="#af1ec0e9ad1d695c404d6bfc3f40072cc">More...</a><br /></td></tr>
<tr class="separator:af1ec0e9ad1d695c404d6bfc3f40072cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad95db09fc45273615f04bdf3d5a21d40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ad95db09fc45273615f04bdf3d5a21d40">SpillTree</a> ()</td></tr>
<tr class="memdesc:ad95db09fc45273615f04bdf3d5a21d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor.  <a href="#ad95db09fc45273615f04bdf3d5a21d40">More...</a><br /></td></tr>
<tr class="separator:ad95db09fc45273615f04bdf3d5a21d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afcdf54e764b75f2777ece22ab978ca40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#afcdf54e764b75f2777ece22ab978ca40">SplitNode</a> (arma::Col&lt; size_t &gt; &amp;points, const size_t maxLeafSize, const double tau, const double rho)</td></tr>
<tr class="memdesc:afcdf54e764b75f2777ece22ab978ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the current node, assigning its left and right children recursively.  <a href="#afcdf54e764b75f2777ece22ab978ca40">More...</a><br /></td></tr>
<tr class="separator:afcdf54e764b75f2777ece22ab978ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481745d31885b7bea113758204bc303"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a2481745d31885b7bea113758204bc303">SplitPoints</a> (const double tau, const double rho, const arma::Col&lt; size_t &gt; &amp;points, arma::Col&lt; size_t &gt; &amp;leftPoints, arma::Col&lt; size_t &gt; &amp;rightPoints)</td></tr>
<tr class="memdesc:a2481745d31885b7bea113758204bc303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the list of points.  <a href="#a2481745d31885b7bea113758204bc303">More...</a><br /></td></tr>
<tr class="separator:a2481745d31885b7bea113758204bc303"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab7fbd298a7cd3613abe861476ff2cc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ab7fbd298a7cd3613abe861476ff2cc5f">bound</a></td></tr>
<tr class="memdesc:ab7fbd298a7cd3613abe861476ff2cc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bound object for this node.  <a href="#ab7fbd298a7cd3613abe861476ff2cc5f">More...</a><br /></td></tr>
<tr class="separator:ab7fbd298a7cd3613abe861476ff2cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85648cacf8719be43a6534e6c33b37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aca85648cacf8719be43a6534e6c33b37">count</a></td></tr>
<tr class="memdesc:aca85648cacf8719be43a6534e6c33b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of points of the dataset contained in this node (and its children).  <a href="#aca85648cacf8719be43a6534e6c33b37">More...</a><br /></td></tr>
<tr class="separator:aca85648cacf8719be43a6534e6c33b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56354d3af9273a689fc3634f43fda61a"><td class="memItemLeft" align="right" valign="top">const MatType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a56354d3af9273a689fc3634f43fda61a">dataset</a></td></tr>
<tr class="memdesc:a56354d3af9273a689fc3634f43fda61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataset.  <a href="#a56354d3af9273a689fc3634f43fda61a">More...</a><br /></td></tr>
<tr class="separator:a56354d3af9273a689fc3634f43fda61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba4713f1d2a6feae5ffda01e9cf134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a40ba4713f1d2a6feae5ffda01e9cf134">furthestDescendantDistance</a></td></tr>
<tr class="memdesc:a40ba4713f1d2a6feae5ffda01e9cf134"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worst possible distance to the furthest descendant, cached to speed things up.  <a href="#a40ba4713f1d2a6feae5ffda01e9cf134">More...</a><br /></td></tr>
<tr class="separator:a40ba4713f1d2a6feae5ffda01e9cf134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021457174c05bf5e17fc43bc499c0b2b"><td class="memItemLeft" align="right" valign="top">HyperplaneType&lt; MetricType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a021457174c05bf5e17fc43bc499c0b2b">hyperplane</a></td></tr>
<tr class="memdesc:a021457174c05bf5e17fc43bc499c0b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting hyperplane represented by this node.  <a href="#a021457174c05bf5e17fc43bc499c0b2b">More...</a><br /></td></tr>
<tr class="separator:a021457174c05bf5e17fc43bc499c0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d3004d09c7057be8c849d7d265c588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#af3d3004d09c7057be8c849d7d265c588">left</a></td></tr>
<tr class="memdesc:af3d3004d09c7057be8c849d7d265c588"><td class="mdescLeft">&#160;</td><td class="mdescRight">The left child node.  <a href="#af3d3004d09c7057be8c849d7d265c588">More...</a><br /></td></tr>
<tr class="separator:af3d3004d09c7057be8c849d7d265c588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ead74b4a25d34f6221fef6ddae3caa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a31ead74b4a25d34f6221fef6ddae3caa">localDataset</a></td></tr>
<tr class="memdesc:a31ead74b4a25d34f6221fef6ddae3caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we own the dataset and need to destroy it in the destructor.  <a href="#a31ead74b4a25d34f6221fef6ddae3caa">More...</a><br /></td></tr>
<tr class="separator:a31ead74b4a25d34f6221fef6ddae3caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6709ead9cc97ea742b36d86a38ca56d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a6709ead9cc97ea742b36d86a38ca56d0">minimumBoundDistance</a></td></tr>
<tr class="memdesc:a6709ead9cc97ea742b36d86a38ca56d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance from the center to any edge of the bound.  <a href="#a6709ead9cc97ea742b36d86a38ca56d0">More...</a><br /></td></tr>
<tr class="separator:a6709ead9cc97ea742b36d86a38ca56d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0309a97ec7fadb3ca6baabd3fd3d9986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a0309a97ec7fadb3ca6baabd3fd3d9986">overlappingNode</a></td></tr>
<tr class="memdesc:a0309a97ec7fadb3ca6baabd3fd3d9986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to distinguish overlapping nodes from non-overlapping nodes.  <a href="#a0309a97ec7fadb3ca6baabd3fd3d9986">More...</a><br /></td></tr>
<tr class="separator:a0309a97ec7fadb3ca6baabd3fd3d9986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd7de5c98bd88b4dfbee977e05c9c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5cd7de5c98bd88b4dfbee977e05c9c3b">parent</a></td></tr>
<tr class="memdesc:a5cd7de5c98bd88b4dfbee977e05c9c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent node (NULL if this is the root of the tree).  <a href="#a5cd7de5c98bd88b4dfbee977e05c9c3b">More...</a><br /></td></tr>
<tr class="separator:a5cd7de5c98bd88b4dfbee977e05c9c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d95d83df84b6171d1d757aab81930c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a2d95d83df84b6171d1d757aab81930c2">parentDistance</a></td></tr>
<tr class="memdesc:a2d95d83df84b6171d1d757aab81930c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance from the centroid of this node to the centroid of the parent.  <a href="#a2d95d83df84b6171d1d757aab81930c2">More...</a><br /></td></tr>
<tr class="separator:a2d95d83df84b6171d1d757aab81930c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb3ccd91792473d6dd696073487d273"><td class="memItemLeft" align="right" valign="top">arma::Col&lt; size_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aeeb3ccd91792473d6dd696073487d273">pointsIndex</a></td></tr>
<tr class="memdesc:aeeb3ccd91792473d6dd696073487d273"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of indexes of points contained in this node (non-null for leaf nodes).  <a href="#aeeb3ccd91792473d6dd696073487d273">More...</a><br /></td></tr>
<tr class="separator:aeeb3ccd91792473d6dd696073487d273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6f54dc452dcb8ab57bf2b241fb4d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a3c6f54dc452dcb8ab57bf2b241fb4d46">right</a></td></tr>
<tr class="memdesc:a3c6f54dc452dcb8ab57bf2b241fb4d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The right child node.  <a href="#a3c6f54dc452dcb8ab57bf2b241fb4d46">More...</a><br /></td></tr>
<tr class="separator:a3c6f54dc452dcb8ab57bf2b241fb4d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d2447ace8bb1709d740dc63e6b817"><td class="memItemLeft" align="right" valign="top">StatisticType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a678d2447ace8bb1709d740dc63e6b817">stat</a></td></tr>
<tr class="memdesc:a678d2447ace8bb1709d740dc63e6b817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any extra data contained in the node.  <a href="#a678d2447ace8bb1709d740dc63e6b817">More...</a><br /></td></tr>
<tr class="separator:a678d2447ace8bb1709d740dc63e6b817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType, typename StatisticType = EmptyStatistic, typename MatType = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt;<br />
class mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;</h3>

<p>A hybrid spill tree is a variant of binary space trees in which the children of a node can "spill over" each other, and contain shared datapoints. </p>
<p>Two new separating planes lplane and rplane are defined, both of which are parallel to the original decision boundary and at a distance tau from it. The region between lplane and rplane is called "overlapping buffer".</p>
<p>For each node, we first split the points considering the overlapping buffer. If either of its children contains more than rho fraction of the total points we undo the overlapping splitting. Instead a conventional partition is used. In this way, we can ensure that each split reduces the number of points of a node by at least a constant factor.</p>
<p>This particular tree does not allow growth, so you cannot add or delete nodes from it. If you need to add or delete a node, the better procedure is to rebuild the tree entirely.</p>
<p>Three runtime parameters are required in the constructor:</p><ul>
<li>maxLeafSize: Max leaf size to be used.</li>
<li>tau: Overlapping size.</li>
<li>rho: Balance threshold.</li>
</ul>
<p>For more information on spill trees, see</p>
<div class="fragment"><div class="line">@inproceedings{</div><div class="line">  author = {Ting Liu, Andrew W. Moore, Alexander Gray and Ke Yang},</div><div class="line">  title = {An Investigation of Practical Approximate Nearest Neighbor</div><div class="line">    Algorithms},</div><div class="line">  booktitle = {Advances in Neural Information Processing Systems 17},</div><div class="line">  year = {2005},</div><div class="line">  pages = {825--832}</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>The metric used for tree-building. </td></tr>
    <tr><td class="paramname">StatisticType</td><td>Extra data contained in the node. See <a class="el" href="statistic_8hpp.html" title="Definition of the policy type for the statistic class. ">statistic.hpp</a> for the necessary skeleton interface. </td></tr>
    <tr><td class="paramname">MatType</td><td>The dataset class. </td></tr>
    <tr><td class="paramname">HyperplaneType</td><td>The splitting hyperplane class. </td></tr>
    <tr><td class="paramname">SplitType</td><td>The class that partitions the dataset/points at a particular node into two parts. Its definition decides the way this split is done. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00073">73</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a17fd81b3578ad9c1ba2c21bf8590319d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HyperplaneType&lt;MetricType&gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bound type. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00081">81</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a407ac8fa6f6a73ed61c755933f64ace2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename RuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a407ac8fa6f6a73ed61c755933f64ace2">DefeatistDualTreeTraverser</a> =  <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html">SpillDualTreeTraverser</a>&lt;RuleType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A defeatist dual-tree traverser for hybrid spill trees. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00146">146</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaae1fd43e08b5a226c1daab98efba83d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename RuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#aaae1fd43e08b5a226c1daab98efba83d">DefeatistSingleTreeTraverser</a> =  <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html">SpillSingleTreeTraverser</a>&lt;RuleType, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A defeatist single-tree traverser for hybrid spill trees. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00138">138</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a776c82e8b9d3711dcfdc1e7633c30306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename RuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a776c82e8b9d3711dcfdc1e7633c30306">DualTreeTraverser</a> =  <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillDualTreeTraverser.html">SpillDualTreeTraverser</a>&lt;RuleType, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dual-tree traverser for hybrid spill trees. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00142">142</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5698c45a888029b584108bdc943700af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType::elem_type <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of element held in MatType. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00079">79</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b11ae05884a921d378e734922f8653"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ab0b11ae05884a921d378e734922f8653">Mat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>So other classes can use TreeType::Mat. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00077">77</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02b7fc2ba94d53eaf705541b7fe99a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename RuleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a02b7fc2ba94d53eaf705541b7fe99a30">SingleTreeTraverser</a> =  <a class="el" href="classmlpack_1_1tree_1_1SpillTree_1_1SpillSingleTreeTraverser.html">SpillSingleTreeTraverser</a>&lt;RuleType, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single-tree traverser for hybrid spill trees. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00134">134</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac96f40b48753be633942e0aa199c2696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rho</em> = <code>0.7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a hybrid spill tree using the given dataset. </p>
<p>The dataset will not be modified during the building procedure (unlike <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree. ">BinarySpaceTree</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. </td></tr>
    <tr><td class="paramname">tau</td><td>Overlapping size. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
    <tr><td class="paramname">rho</td><td>Balance threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d80a9b70c117d80e0d6578cf309726b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rho</em> = <code>0.7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this as the root node of a hybrid spill tree using the given dataset. </p>
<p>This will take ownership of the data matrix; if you don't want this, consider using the constructor that takes a const reference to a dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to create tree from. </td></tr>
    <tr><td class="paramname">tau</td><td>Overlapping size. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
    <tr><td class="paramname">rho</td><td>Balance threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c0eb4c71bd9f14f268bc7d308e69df7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rho</em> = <code>0.7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this node as a child of the given parent, including the given list of points. </p>
<p>This is used for recursive tree-building by the other constructors which don't specify point indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of this node. </td></tr>
    <tr><td class="paramname">points</td><td>Vector of indexes of points to be included in this node. </td></tr>
    <tr><td class="paramname">tau</td><td>Overlapping size. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Size of each leaf in the tree. </td></tr>
    <tr><td class="paramname">rho</td><td>Balance threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8523681f12549e5c5d622cfaf833c706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hybrid spill tree by copying the other tree. </p>
<p>Be careful! This can take a long time and use a lot of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>tree to be replicated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad813d9ca5876687d6069518beffbdfe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor for a <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html" title="A hybrid spill tree is a variant of binary space trees in which the children of a node can &quot;spill ove...">SpillTree</a>; possess all the members of the given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>tree to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55ebc56b812906568182cf1b8402e7b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; Archive::is_loading::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the tree from a <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a> archive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>Archive to load tree from. Must be an iarchive, not an oarchive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9a25250eb841f4144bb235e32299a02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::~<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes this node, deallocating the memory for the children and calling their destructors in turn. </p>
<p>This will invalidate any pointers or references to any nodes which are children of this one. </p>

</div>
</div>
<a class="anchor" id="ad95db09fc45273615f04bdf3d5a21d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor. </p>
<p>This is meant to only be used with <a class="el" href="namespaceboost_1_1serialization.html">boost::serialization</a>, which is allowed with the friend declaration below. This does not return a valid tree! The method must be protected, so that the serialization shim can work with the default constructor. </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00424">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Center()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a284c6e2186de53946f5ba5906bfbec85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bound object for this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00230">230</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00101">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::bound</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00382">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MaxDistance()</a>, <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00376">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MinDistance()</a>, and <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00388">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::RangeDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a9af02115e7005043125d967e5cb7c7f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bound object for this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00232">232</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00101">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::bound</a>.</p>

</div>
</div>
<a class="anchor" id="a6e896b966e7cd965b06954c83b911ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Center </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the center of the bounding region in the given vector. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00424">424</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ad95db09fc45273615f04bdf3d5a21d40">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::SpillTree()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#afcdf54e764b75f2777ece22ab978ca40">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::SplitNode()</a>, and <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a2481745d31885b7bea113758204bc303">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::SplitPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e22ba4810151bbe4fa884190e199d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the specified child (0 will be left, 1 will be right). </p>
<p>If the index is greater than 1, this will return the right child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>Index of child to return. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00333">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ParentDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="a02faee35dd9e74c8b9f4b4691579d4c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">343</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#ae241a75ccb0f50802b64143c35f71a03">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Descendant()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a330791a347eadf429808ef4fb4f5e0d8">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumDescendants()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a94b30aac8ab1016393544e13382de438">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumPoints()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a69f650191492eee6c5bd4c53d4fe6dd8">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Point()</a>, and <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00087">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::right</a>.</p>

</div>
</div>
<a class="anchor" id="a247403cd94290da5dd752f5a77c4aee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dataset which the tree is built on. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00258">258</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00113">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::dataset</a>.</p>

</div>
</div>
<a class="anchor" id="ae241a75ccb0f50802b64143c35f71a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Descendant </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular descendant of this node. </p>
<p>The index should be greater than zero but less than the number of descendants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the descendant. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="af64b2b9ca6117b3cf89c41a80b278532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::FurthestDescendantDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest possible descendant distance. </p>
<p>This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="acfbe3ee7cd1b1b77a6b4291d473059e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::FurthestPointDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the furthest distance to a point held in this node. </p>
<p>If this is not a leaf node, then the distance is 0 because the node holds no points. </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d748e559c8ac083cd5803a0aaffc354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f2f70ae3392aa7eaa412ddffee6034d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). </p>
<p>If it can't decide it will return <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a class="anchor" id="a66015f3c1d1c981b38baee9867e05330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a50785371927a61d7236b8ae962de4d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). </p>
<p>If it can't decide it will return <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf" title="Return the number of children in this node. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a class="anchor" id="af1ec0e9ad1d695c404d6bfc3f40072cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::HasSelfChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false: this tree type does not have self children. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00421">421</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49e18c815ff2459feab39e6b4b8795fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const HyperplaneType&lt;MetricType&gt;&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::<a class="el" href="namespacemlpack_1_1tree.html#ab58a5d5d9fb70b74d391ffb929cfd00a">Hyperplane</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Hyperplane instance. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00264">264</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00099">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::hyperplane</a>.</p>

</div>
</div>
<a class="anchor" id="a1992b8610849049501a0f39cce136d51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::IsLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether or not this node is a leaf (true if it has no children). </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00237">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Stat()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0aa14bd2cb0ab2a5059781f290ec88b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the left child of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00243">243</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00085">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::left</a>.</p>

</div>
</div>
<a class="anchor" id="a9fbc5932a9fdc72e8eaea4b6b478a968"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the left child of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00245">245</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00085">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::left</a>.</p>

</div>
</div>
<a class="anchor" id="a532a790cb96a882c5cf96a2e1f07d2f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum distance to another node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00382">382</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00230">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a class="anchor" id="aa541b880f75f73d0bfd3b4da8fc12c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum distance to another point. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00404">404</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac1e93b1d7fad7a472cb689d9b7b93f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the metric that the tree uses. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">267</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#af64b2b9ca6117b3cf89c41a80b278532">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::FurthestDescendantDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#acfbe3ee7cd1b1b77a6b4291d473059e8">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::FurthestPointDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a7d748e559c8ac083cd5803a0aaffc354">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetFurthestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a66015f3c1d1c981b38baee9867e05330">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::GetNearestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a1a0721e0735177434b262293cefb19e3">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MinimumBoundDistance()</a>, and <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a20190e12a6b9c7ab7c52f73b516bb3bf">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumChildren()</a>.</p>

</div>
</div>
<a class="anchor" id="aff6b18234af0f93400a8bf3dbf85d572"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MinDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum distance to another node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00376">376</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00230">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a858cfecadd0072283606c9f44b2031c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MinDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum distance to another point. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00395">395</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a0721e0735177434b262293cefb19e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::MinimumBoundDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance from the center of the node to any bound edge. </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a20190e12a6b9c7ab7c52f73b516bb3bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of children in this node. </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00267">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a330791a347eadf429808ef4fb4f5e0d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of descendants of this node. </p>
<p>For a non-leaf spill tree, this is the number of points at the descendant leaves. For a leaf, this is the number of points in the leaf. </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a94b30aac8ab1016393544e13382de438"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::NumPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of points in this node (0 if not a leaf). </p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a6fee7d736b7d529587a23f7379fbed76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Overlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distinguish overlapping nodes from non-overlapping nodes. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00261">261</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00097">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::overlappingNode</a>.</p>

</div>
</div>
<a class="anchor" id="ab0c4368a28681f0b9b6b8240cae9a85c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00253">253</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00089">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parent</a>.</p>

</div>
</div>
<a class="anchor" id="ad28d4e02e3f2044fa692a508b4f52602"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the parent of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00255">255</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00089">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parent</a>.</p>

</div>
</div>
<a class="anchor" id="a90011a35463b64ac7e11f53a1e1e3160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance from the center of this node to the center of the parent node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00330">330</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00105">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parentDistance</a>.</p>

</div>
</div>
<a class="anchor" id="a1efc45482288c77246cd7c71e64a7de6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance from the center of this node to the center of the parent node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00333">333</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a3e22ba4810151bbe4fa884190e199d92">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Child()</a>, and <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00105">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parentDistance</a>.</p>

</div>
</div>
<a class="anchor" id="a69f650191492eee6c5bd4c53d4fe6dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Point </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index (with reference to the dataset) of a particular point in this node. </p>
<p>This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a94b30aac8ab1016393544e13382de438" title="Return the number of points in this node (0 if not a leaf). ">NumPoints()</a>) &ndash; be careful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of point for which a dataset index is wanted. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2b673b990e6453cee38476b6c62c703"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&gt; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00388">388</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00230">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b075950256b6f058e459644f1fbdae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename VecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1math_1_1RangeType.html">math::RangeType</a>&lt;<a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a>&gt; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#ac774dbdf8ae769197167b2a8273462fc">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another point. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00414">414</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3accade12965b3fa514e1fe5f0d8a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the right child of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00248">248</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00087">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::right</a>.</p>

</div>
</div>
<a class="anchor" id="a46375a4336e0fef8c52821e5029926f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>*&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the right child of this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00250">250</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00087">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::right</a>.</p>

</div>
</div>
<a class="anchor" id="a6897e914aad2bdfb8328c1ccaf4c65e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the tree. </p>

</div>
</div>
<a class="anchor" id="afcdf54e764b75f2777ece22ab978ca40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::SplitNode </td>
          <td>(</td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxLeafSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the current node, assigning its left and right children recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of indexes of points to be included in this node. </td></tr>
    <tr><td class="paramname">maxLeafSize</td><td>Maximum number of points held in a leaf. </td></tr>
    <tr><td class="paramname">tau</td><td>Overlapping size. </td></tr>
    <tr><td class="paramname">rho</td><td>Balance threshold. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00424">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Center()</a>.</p>

</div>
</div>
<a class="anchor" id="a2481745d31885b7bea113758204bc303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::SplitPoints </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>leftPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rightPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the list of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tau</td><td>Overlapping size. </td></tr>
    <tr><td class="paramname">rho</td><td>Balance threshold. </td></tr>
    <tr><td class="paramname">points</td><td>Vector of indexes of points to be included. </td></tr>
    <tr><td class="paramname">leftPoints</td><td>Indexes of points to be included in left child. </td></tr>
    <tr><td class="paramname">rightPoints</td><td>Indexes of points to be included in right child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag to know if the overlapping buffer was included. </dd></dl>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00424">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Center()</a>.</p>

</div>
</div>
<a class="anchor" id="a07864908e6a19c4ae69a837a8fadd993"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the statistic object for this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00235">235</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00103">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::stat</a>.</p>

</div>
</div>
<a class="anchor" id="afea9e6f62544ec7d08297113f885d923"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType&amp; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the statistic object for this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00237">237</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>References <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a1992b8610849049501a0f39cce136d51">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::IsLeaf()</a>, and <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00103">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::stat</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab7fbd298a7cd3613abe861476ff2cc5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a17fd81b3578ad9c1ba2c21bf8590319d">BoundType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::bound</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bound object for this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00101">101</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00230">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Bound()</a>.</p>

</div>
</div>
<a class="anchor" id="aca85648cacf8719be43a6534e6c33b37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of points of the dataset contained in this node (and its children). </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00092">92</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56354d3af9273a689fc3634f43fda61a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::dataset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dataset. </p>
<p>If we are the root of the tree, we own the dataset and must delete it. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00113">113</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00258">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Dataset()</a>.</p>

</div>
</div>
<a class="anchor" id="a40ba4713f1d2a6feae5ffda01e9cf134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::furthestDescendantDistance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The worst possible distance to the furthest descendant, cached to speed things up. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00108">108</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a021457174c05bf5e17fc43bc499c0b2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HyperplaneType&lt;MetricType&gt; <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::hyperplane</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splitting hyperplane represented by this node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00099">99</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00264">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Hyperplane()</a>.</p>

</div>
</div>
<a class="anchor" id="af3d3004d09c7057be8c849d7d265c588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The left child node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00085">85</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00243">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Left()</a>.</p>

</div>
</div>
<a class="anchor" id="a31ead74b4a25d34f6221fef6ddae3caa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::localDataset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we own the dataset and need to destroy it in the destructor. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00115">115</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6709ead9cc97ea742b36d86a38ca56d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::minimumBoundDistance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum distance from the center to any edge of the bound. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00110">110</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0309a97ec7fadb3ca6baabd3fd3d9986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::overlappingNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to distinguish overlapping nodes from non-overlapping nodes. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00097">97</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00261">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Overlap()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd7de5c98bd88b4dfbee977e05c9c3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parent node (NULL if this is the root of the tree). </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00089">89</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00253">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Parent()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d95d83df84b6171d1d757aab81930c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html#a5698c45a888029b584108bdc943700af">ElemType</a> <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::parentDistance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The distance from the centroid of this node to the centroid of the parent. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00105">105</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00330">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ParentDistance()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeb3ccd91792473d6dd696073487d273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arma::Col&lt;size_t&gt;* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::pointsIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of indexes of points contained in this node (non-null for leaf nodes). </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00095">95</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c6f54dc452dcb8ab57bf2b241fb4d46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">SpillTree</a>* <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::right</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The right child node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00087">87</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00343">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::ChildPtr()</a>, and <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00248">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Right()</a>.</p>

</div>
</div>
<a class="anchor" id="a678d2447ace8bb1709d740dc63e6b817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType , typename StatisticType  = EmptyStatistic, typename MatType  = arma::mat, template&lt; typename HyperplaneMetricType &gt; class HyperplaneType = AxisOrthogonalHyperplane, template&lt; typename SplitMetricType, typename SplitMatType &gt; class SplitType = MidpointSpaceSplit&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType <a class="el" href="classmlpack_1_1tree_1_1SpillTree.html">mlpack::tree::SpillTree</a>&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::stat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any extra data contained in the node. </p>

<p>Definition at line <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00103">103</a> of file <a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="spill__tree_2spill__tree_8hpp_source.html#l00235">mlpack::tree::SpillTree&lt; MetricType, StatisticType, MatType, HyperplaneType, SplitType &gt;::Stat()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/core/tree/spill_tree/<a class="el" href="spill__tree_2spill__tree_8hpp_source.html">spill_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
<script type="text/javascript">
var x = document.getElementsByClassName("formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width /= 4;
}
</script>
</html>
